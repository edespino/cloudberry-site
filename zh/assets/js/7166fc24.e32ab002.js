"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[66191],{78360:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=i(85893),t=i(11151);const r={title:"Best Practices Summary"},a="Best Practices Summary",l={id:"tutorials/best-practices/index",title:"Best Practices Summary",description:"A summary of best practices for Apache Cloudberry.",source:"@site/versioned_docs/version-2.x/tutorials/best-practices/index.md",sourceDirName:"tutorials/best-practices",slug:"/tutorials/best-practices/",permalink:"/zh/docs/tutorials/best-practices/",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/tutorials/best-practices/index.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756369829,formattedLastUpdatedAt:"2025\u5e748\u670828\u65e5",frontMatter:{title:"Best Practices Summary"},sidebar:"docsbars",previous:{title:"About Management and Monitoring Utilities",permalink:"/zh/docs/tutorials/product-principles/about-utilities"},next:{title:"Schema Design Best Practices",permalink:"/zh/docs/tutorials/best-practices/schema-design-best-practices"}},o={},d=[{value:"Data model",id:"data-model",level:2},{value:"Heap vs. append-optimized storage",id:"heap-vs-append-optimized-storage",level:2},{value:"Row vs. column oriented storage",id:"row-vs-column-oriented-storage",level:2},{value:"Compression",id:"compression",level:2},{value:"Distributions",id:"distributions",level:2},{value:"Resource queue memory management",id:"resource-queue-memory-management",level:2},{value:"Partitioning",id:"partitioning",level:2},{value:"Indexes",id:"indexes",level:2},{value:"Monitoring and maintenance",id:"monitoring-and-maintenance",level:2},{value:"ANALYZE",id:"analyze",level:2},{value:"Vacuum",id:"vacuum",level:2},{value:"Loading",id:"loading",level:2},{value:"Security",id:"security",level:2},{value:"Encryption",id:"encryption",level:2},{value:"High availability",id:"high-availability",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsx)(n.p,{children:"A summary of best practices for Apache Cloudberry."}),"\n",(0,s.jsx)(n.h2,{id:"data-model",children:"Data model"}),"\n",(0,s.jsx)(n.p,{children:"Apache Cloudberry is an analytical MPP shared-nothing database. This model is significantly different from a highly normalized/transactional SMP database. Because of this, the following best practices are recommended."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Apache Cloudberry performs best with a denormalized schema design suited for MPP analytical processing for example, Star or Snowflake schema, with large fact tables and smaller dimension tables."}),"\n",(0,s.jsx)(n.li,{children:"Use the same data types for columns used in joins between tables."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices",children:"Schema Design"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"heap-vs-append-optimized-storage",children:"Heap vs. append-optimized storage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use heap storage for tables and partitions that will receive iterative batch and singleton ",(0,s.jsx)(n.code,{children:"UPDATE"}),", ",(0,s.jsx)(n.code,{children:"DELETE"}),", and ",(0,s.jsx)(n.code,{children:"INSERT"})," operations."]}),"\n",(0,s.jsxs)(n.li,{children:["Use heap storage for tables and partitions that will receive concurrent ",(0,s.jsx)(n.code,{children:"UPDATE"}),", ",(0,s.jsx)(n.code,{children:"DELETE"}),", and ",(0,s.jsx)(n.code,{children:"INSERT"})," operations."]}),"\n",(0,s.jsx)(n.li,{children:"Use append-optimized storage for tables and partitions that are updated infrequently after the initial load and have subsequent inserts only performed in large batch operations."}),"\n",(0,s.jsxs)(n.li,{children:["Avoid performing singleton ",(0,s.jsx)(n.code,{children:"INSERT"}),", ",(0,s.jsx)(n.code,{children:"UPDATE"}),", or ",(0,s.jsx)(n.code,{children:"DELETE"})," operations on append-optimized tables."]}),"\n",(0,s.jsxs)(n.li,{children:["Avoid performing concurrent batch ",(0,s.jsx)(n.code,{children:"UPDATE"})," or ",(0,s.jsx)(n.code,{children:"DELETE"})," operations on append-optimized tables. Concurrent batch ",(0,s.jsx)(n.code,{children:"INSERT"})," operations are acceptable."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices#heap-storage-or-append-optimized-storage",children:"Heap Storage or Append-Optimized Storage"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"row-vs-column-oriented-storage",children:"Row vs. column oriented storage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use row-oriented storage for workloads with iterative transactions where updates are required and frequent inserts are performed."}),"\n",(0,s.jsx)(n.li,{children:"Use row-oriented storage when selects against the table are wide."}),"\n",(0,s.jsx)(n.li,{children:"Use row-oriented storage for general purpose or mixed workloads."}),"\n",(0,s.jsx)(n.li,{children:"Use column-oriented storage where selects are narrow and aggregations of data are computed over a small number of columns."}),"\n",(0,s.jsx)(n.li,{children:"Use column-oriented storage for tables that have single columns that are regularly updated without modifying other columns in the row."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices#row-or-column-orientation",children:"Row or Column Orientation"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"compression",children:"Compression"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use compression on large append-optimized and partitioned tables to improve I/O across the system."}),"\n",(0,s.jsx)(n.li,{children:"Set the column compression settings at the level where the data resides."}),"\n",(0,s.jsx)(n.li,{children:"Balance higher levels of compression with the time and CPU cycles needed to compress and uncompress data."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices",children:"Compression"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"distributions",children:"Distributions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explicitly define a column or random distribution for all tables. Do not use the default."}),"\n",(0,s.jsx)(n.li,{children:"Use a single column that will distribute data across all segments evenly."}),"\n",(0,s.jsxs)(n.li,{children:["Do not distribute on columns that will be used in the ",(0,s.jsx)(n.code,{children:"WHERE"})," clause of a query."]}),"\n",(0,s.jsx)(n.li,{children:"Do not distribute on dates or timestamps."}),"\n",(0,s.jsx)(n.li,{children:"Never distribute and partition tables on the same column."}),"\n",(0,s.jsx)(n.li,{children:"Achieve local joins to significantly improve performance by distributing on the same column for large tables commonly joined together."}),"\n",(0,s.jsx)(n.li,{children:"To ensure there is no data skew, validate that data is evenly distributed after the initial load and after incremental loads."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices",children:"Distributions"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"resource-queue-memory-management",children:"Resource queue memory management"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"vm.overcommit_memory"})," to 2."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Do not configure the OS to use huge pages."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"gp_vmem_protect_limit"})," to set the maximum memory that the instance can allocate for ",(0,s.jsx)(n.em,{children:"all"})," work being done in each segment database."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"gp_vmem_protect_limit"})," by calculating:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"gp_vmem"})," \u2013 the total memory available to Apache Cloudberry"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the total system memory is less than 256 GB, use this formula:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM)) / 1.7\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the total system memory is equal to or greater than 256 GB, use this formula:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM)) / 1.17\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"SWAP"})," is the host's swap space in GB, and ",(0,s.jsx)(n.code,{children:"RAM"})," is the host's RAM in GB."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"max_acting_primary_segments"})," \u2013 the maximum number of primary segments that could be running on a host when mirror segments are activated due to a host or segment failure."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"gp_vmem_protect_limit"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"gp_vmem_protect_limit = gp_vmem / acting_primary_segments\n"})}),"\n",(0,s.jsx)(n.p,{children:"Convert to MB to set the value of the configuration parameter."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In a scenario where a large number of workfiles are generated calculate the ",(0,s.jsx)(n.code,{children:"gp_vmem"})," factor with this formula to account for the workfiles."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the total system memory is less than 256 GB:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM - (300KB *\n      total_#_workfiles))) / 1.7\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the total system memory is equal to or greater than 256 GB:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM - (300KB *\n      total_#_workfiles))) / 1.17\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Never set ",(0,s.jsx)(n.code,{children:"gp_vmem_protect_limit"})," too high or larger than the physical RAM on the system."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use the calculated ",(0,s.jsx)(n.code,{children:"gp_vmem"})," value to calculate the setting for the ",(0,s.jsx)(n.code,{children:"vm.overcommit_ratio"})," operating system parameter:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"vm.overcommit_ratio = (RAM - 0.026 * gp_vmem) / RAM\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"statement_mem"})," to allocate memory used for a query per segment db."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use resource queues to set both the numbers of active queries (",(0,s.jsx)(n.code,{children:"ACTIVE_STATEMENTS"}),") and the amount of memory (",(0,s.jsx)(n.code,{children:"MEMORY_LIMIT"}),") that can be utilized by queries in the queue."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Associate all users with a resource queue. Do not use the default queue."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Set ",(0,s.jsx)(n.code,{children:"PRIORITY"})," to match the real needs of the queue for the workload and time of day. Avoid using MAX priority."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Ensure that resource queue memory allocations do not exceed the setting for ",(0,s.jsx)(n.code,{children:"gp_vmem_protect_limit"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dynamically update resource queue settings to match daily operations flow."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/deployment/system-settings",children:"Setting the Cloudberry Recommended OS Parameters"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"partitioning",children:"Partitioning"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Partition large tables only. Do not partition small tables."}),"\n",(0,s.jsx)(n.li,{children:"Use partitioning only if partition elimination (partition pruning) can be achieved based on the query criteria."}),"\n",(0,s.jsx)(n.li,{children:"Choose range partitioning over list partitioning."}),"\n",(0,s.jsx)(n.li,{children:"Partition the table based on a commonly-used column, such as a date column."}),"\n",(0,s.jsx)(n.li,{children:"Never partition and distribute tables on the same column."}),"\n",(0,s.jsx)(n.li,{children:"Do not use default partitions."}),"\n",(0,s.jsx)(n.li,{children:"Do not use multi-level partitioning; create fewer partitions with more data in each partition."}),"\n",(0,s.jsxs)(n.li,{children:["Validate that queries are selectively scanning partitioned tables (partitions are being eliminated) by examining the query ",(0,s.jsx)(n.code,{children:"EXPLAIN"})," plan."]}),"\n",(0,s.jsxs)(n.li,{children:["Do not create too many partitions with column-oriented storage because of the total number of physical files on every segment: ",(0,s.jsx)(n.code,{children:"physical files = segments x columns x partitions"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/schema-design-best-practices",children:"Schema Design"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"indexes",children:"Indexes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In general indexes are not needed in Apache Cloudberry."}),"\n",(0,s.jsx)(n.li,{children:"Create an index on a single column of a columnar table for drill-through purposes for high cardinality tables that require queries with high selectivity."}),"\n",(0,s.jsx)(n.li,{children:"Do not index columns that are frequently updated."}),"\n",(0,s.jsx)(n.li,{children:"Consider dropping indexes before loading data into a table. After the load, re-create the indexes for the table."}),"\n",(0,s.jsx)(n.li,{children:"Create selective B-tree indexes."}),"\n",(0,s.jsx)(n.li,{children:"Do not create bitmap indexes on columns that are updated."}),"\n",(0,s.jsx)(n.li,{children:"Avoid using bitmap indexes for unique columns, very high or very low cardinality data. Bitmap indexes perform best when the column has a low cardinality\u2014100 to 100,000 distinct values."}),"\n",(0,s.jsx)(n.li,{children:"Do not use bitmap indexes for transactional workloads."}),"\n",(0,s.jsx)(n.li,{children:"In general do not index partitioned tables. If indexes are needed, the index columns must be different than the partition columns."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"monitoring-and-maintenance",children:"Monitoring and maintenance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Implement the "Recommended Monitoring and Maintenance Tasks".'}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"gpcheckperf"})," at install time and periodically thereafter, saving the output to compare system performance over time."]}),"\n",(0,s.jsx)(n.li,{children:"Use all the tools at your disposal to understand how your system behaves under different loads."}),"\n",(0,s.jsx)(n.li,{children:"Examine any unusual event to determine the cause."}),"\n",(0,s.jsx)(n.li,{children:"Monitor query activity on the system by running explain plans periodically to ensure the queries are running optimally."}),"\n",(0,s.jsx)(n.li,{children:"Review plans to determine whether index are being used and partition elimination is occurring as expected."}),"\n",(0,s.jsx)(n.li,{children:"Know the location and content of system log files and monitor them on a regular basis, not just when problems arise."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/system-monitor-and-maintain-best-practices",children:"System Monitoring and Maintenance"}),", ",(0,s.jsx)(n.a,{href:"../../performance/optimize-queries/analyze-query-performance.md",children:"Query Profiling"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"analyze",children:"ANALYZE"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Determine if analyzing the database is actually needed. Analyzing is not needed if ",(0,s.jsx)(n.code,{children:"gp_autostats_mode"})," is set to ",(0,s.jsx)(n.code,{children:"on_no_stats"})," (the default) and the table is not partitioned."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"analyzedb"})," in preference to ",(0,s.jsx)(n.code,{children:"ANALYZE"})," when dealing with large sets of tables, as it does not require analyzing the entire database. The ",(0,s.jsx)(n.code,{children:"analyzedb"})," utility updates statistics data for the specified tables incrementally and concurrently. For append optimized tables, ",(0,s.jsx)(n.code,{children:"analyzedb"})," updates statistics incrementally only if the statistics are not current. For heap tables, statistics are always updated. ",(0,s.jsx)(n.code,{children:"ANALYZE"})," does not update the table metadata that the ",(0,s.jsx)(n.code,{children:"analyzedb"})," utility uses to determine whether table statistics are up to date."]}),"\n",(0,s.jsxs)(n.li,{children:["Selectively run ",(0,s.jsx)(n.code,{children:"ANALYZE"})," at the table level when needed."]}),"\n",(0,s.jsxs)(n.li,{children:["Always run ",(0,s.jsx)(n.code,{children:"ANALYZE"})," after ",(0,s.jsx)(n.code,{children:"INSERT"}),", ",(0,s.jsx)(n.code,{children:"UPDATE"}),". and ",(0,s.jsx)(n.code,{children:"DELETE"})," operations that significantly changes the underlying data."]}),"\n",(0,s.jsxs)(n.li,{children:["Always run ",(0,s.jsx)(n.code,{children:"ANALYZE"})," after ",(0,s.jsx)(n.code,{children:"CREATE INDEX"})," operations."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"ANALYZE"})," on very large tables takes too long, run ",(0,s.jsx)(n.code,{children:"ANALYZE"})," only on the columns used in a join condition, ",(0,s.jsx)(n.code,{children:"WHERE"})," clause, ",(0,s.jsx)(n.code,{children:"SORT"}),", ",(0,s.jsx)(n.code,{children:"GROUP BY"}),", or ",(0,s.jsx)(n.code,{children:"HAVING"})," clause."]}),"\n",(0,s.jsxs)(n.li,{children:["When dealing with large sets of tables, use ",(0,s.jsx)(n.code,{children:"analyzedb"})," instead of ",(0,s.jsx)(n.code,{children:"ANALYZE."})]}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"analyzedb"})," on the root partition any time that you add a new partition(s) to a partitioned table. This operation both analyzes the leaf partitions in parallel and merges any updated statistics into the root partition."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../../performance/update-stats-using-analyze.md",children:"Updating Statistics with ANALYZE"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"vacuum",children:"Vacuum"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"VACUUM"})," after large ",(0,s.jsx)(n.code,{children:"UPDATE"})," and ",(0,s.jsx)(n.code,{children:"DELETE"})," operations."]}),"\n",(0,s.jsxs)(n.li,{children:["Do not run ",(0,s.jsx)(n.code,{children:"VACUUM FULL"}),". Instead run a ",(0,s.jsx)(n.code,{children:"CREATE TABLE...AS"})," operation, then rename and drop the original table."]}),"\n",(0,s.jsxs)(n.li,{children:["Frequently run ",(0,s.jsx)(n.code,{children:"VACUUM"})," on the system catalogs to avoid catalog bloat and the need to run ",(0,s.jsx)(n.code,{children:"VACUUM FULL"})," on catalog tables."]}),"\n",(0,s.jsxs)(n.li,{children:["Never issue a ",(0,s.jsx)(n.code,{children:"kill"})," command against ",(0,s.jsx)(n.code,{children:"VACUUM"})," on catalog tables."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/manage-bloat",children:"Managing Bloat in a Database"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"loading",children:"Loading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximize the parallelism as the number of segments increase."}),"\n",(0,s.jsxs)(n.li,{children:["Spread the data evenly across as many ETL nodes as possible.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Split very large data files into equal parts and spread the data across as many file systems as possible."}),"\n",(0,s.jsxs)(n.li,{children:["Run two ",(0,s.jsx)(n.code,{children:"gpfdist"})," instances per file system."]}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"gpfdist"})," on as many interfaces as possible."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"gp_external_max_segs"})," to control the number of segments that will request data from the ",(0,s.jsx)(n.code,{children:"gpfdist"})," process."]}),"\n",(0,s.jsxs)(n.li,{children:["Always keep ",(0,s.jsx)(n.code,{children:"gp_external_max_segs"})," and the number of ",(0,s.jsx)(n.code,{children:"gpfdist"})," processes an even factor."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Always drop indexes before loading into existing tables and re-create the index after loading."}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"VACUUM"})," after load errors to recover space."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/load-data-best-practices",children:"Loading Data"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Secure the ",(0,s.jsx)(n.code,{children:"gpadmin"})," user id and only allow essential system administrators access to it."]}),"\n",(0,s.jsxs)(n.li,{children:["Administrators should only log in to Cloudberry as ",(0,s.jsx)(n.code,{children:"gpadmin"})," when performing certain system maintenance tasks (such as upgrade or expansion)."]}),"\n",(0,s.jsxs)(n.li,{children:["Limit users who have the ",(0,s.jsx)(n.code,{children:"SUPERUSER"})," role attribute. Roles that are superusers bypass all access privilege checks in Apache Cloudberry, as well as resource queuing. Only system administrators should be given superuser rights."]}),"\n",(0,s.jsxs)(n.li,{children:["Database users should never log on as ",(0,s.jsx)(n.code,{children:"gpadmin"}),", and ETL or production workloads should never run as ",(0,s.jsx)(n.code,{children:"gpadmin"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Assign a distinct Apache Cloudberry role to each user, application, or service that logs in."}),"\n",(0,s.jsx)(n.li,{children:"For applications or web services, consider creating a distinct role for each application or service."}),"\n",(0,s.jsx)(n.li,{children:"Use groups to manage access privileges."}),"\n",(0,s.jsx)(n.li,{children:"Protect the root password."}),"\n",(0,s.jsx)(n.li,{children:"Enforce a strong password password policy for operating system passwords."}),"\n",(0,s.jsx)(n.li,{children:"Ensure that important operating system files are protected."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/security-best-practices",children:"Security"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"encryption",children:"Encryption"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Encrypting and decrypting data has a performance cost; only encrypt data that requires encryption."}),"\n",(0,s.jsx)(n.li,{children:"Do performance testing before implementing any encryption solution in a production system."}),"\n",(0,s.jsx)(n.li,{children:"Server certificates in a production Apache Cloudberry system should be signed by a certificate authority (CA) so that clients can authenticate the server. The CA may be local if all clients are local to the organization."}),"\n",(0,s.jsx)(n.li,{children:"Client connections to Apache Cloudberry should use SSL encryption whenever the connection goes through an insecure link."}),"\n",(0,s.jsx)(n.li,{children:"A symmetric encryption scheme, where the same key is used to both encrypt and decrypt, has better performance than an asymmetric scheme and should be used when the key can be shared safely."}),"\n",(0,s.jsx)(n.li,{children:"Use cryptographic functions to encrypt data on disk. The data is encrypted and decrypted in the database process, so it is important to secure the client connection with SSL to avoid transmitting unencrypted data."}),"\n",(0,s.jsx)(n.li,{children:"Use the gpfdists protocol to secure ETL data as it is loaded into or unloaded from the database."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/db-encryption-best-practices",children:"Encrypting Data and Database Connections"})]}),"\n",(0,s.jsx)(n.h2,{id:"high-availability",children:"High availability"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"})," The following guidelines apply to actual hardware deployments, but not to public cloud-based infrastructure, where high availability solutions may already exist."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use a hardware RAID storage solution with 8 to 24 disks."}),"\n",(0,s.jsx)(n.li,{children:"Use RAID 1, 5, or 6 so that the disk array can tolerate a failed disk."}),"\n",(0,s.jsx)(n.li,{children:"Configure a hot spare in the disk array to allow rebuild to begin automatically when disk failure is detected."}),"\n",(0,s.jsx)(n.li,{children:"Protect against failure of the entire disk array and degradation during rebuilds by mirroring the RAID volume."}),"\n",(0,s.jsx)(n.li,{children:"Monitor disk utilization regularly and add additional space when needed."}),"\n",(0,s.jsx)(n.li,{children:"Monitor segment skew to ensure that data is distributed evenly and storage is consumed evenly at all segments."}),"\n",(0,s.jsx)(n.li,{children:"Set up a standby coordinator instance to take over if the primary coordinator fails."}),"\n",(0,s.jsx)(n.li,{children:"Plan how to switch clients to the new coordinator instance when a failure occurs, for example, by updating the coordinator address in DNS."}),"\n",(0,s.jsx)(n.li,{children:"Set up monitoring to send notifications in a system monitoring application or by email when the primary fails."}),"\n",(0,s.jsx)(n.li,{children:"Set up mirrors for all segments."}),"\n",(0,s.jsx)(n.li,{children:"Locate primary segments and their mirrors on different hosts to protect against host failure."}),"\n",(0,s.jsxs)(n.li,{children:["Recover failed segments promptly, using the ",(0,s.jsx)(n.code,{children:"gprecoverseg"})," utility, to restore redundancy and return the system to optimal balance."]}),"\n",(0,s.jsx)(n.li,{children:"Consider a Dual Cluster configuration to provide an additional level of redundancy and additional query processing throughput."}),"\n",(0,s.jsx)(n.li,{children:"Backup Apache Cloudberry databases regularly unless the data is easily restored from sources."}),"\n",(0,s.jsx)(n.li,{children:"If backups are saved to local cluster storage, move the files to a safe, off-cluster location when the backup is complete."}),"\n",(0,s.jsx)(n.li,{children:"If backups are saved to NFS mounts, use a scale-out NFS solution such as Dell EMC Isilon to prevent IO bottlenecks."}),"\n",(0,s.jsx)(n.li,{children:"Consider using Cloudberry integration to stream backups to the Dell EMC Data Domain enterprise backup platform."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh/docs/tutorials/best-practices/high-availability-best-practices",children:"High Availability"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>a});var s=i(67294);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
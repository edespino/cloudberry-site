"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[5998],{63390:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var o=s(85893),i=s(11151);const r={title:"Queries with Window Functions"},a="Queries with Window Functions",t={id:"operate-with-data/sql-queries/window-functions",title:"Queries with Window Functions",description:"Window expressions allow application developers to more easily compose complex online analytical processing (OLAP) queries using standard SQL commands. For example, with window expressions, users can calculate moving averages or sums over various intervals, reset aggregations and ranks as selected column values change, and express complex ratios in simple terms.",source:"@site/versioned_docs/version-2.x/operate-with-data/sql-queries/window-functions.md",sourceDirName:"operate-with-data/sql-queries",slug:"/operate-with-data/sql-queries/window-functions",permalink:"/docs/operate-with-data/sql-queries/window-functions",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/sql-queries/window-functions.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756102252,formattedLastUpdatedAt:"Aug 25, 2025",frontMatter:{title:"Queries with Window Functions"},sidebar:"docsbars",previous:{title:"Table Functions",permalink:"/docs/operate-with-data/sql-queries/table-functions"},next:{title:"Full Text Search",permalink:"/docs/operate-with-data/sql-queries/full-text-search/"}},d={},c=[{value:"Window examples",id:"window-examples",level:2},{value:"Example 1 \u2013 Aggregate window function over a partition",id:"example-1--aggregate-window-function-over-a-partition",level:3},{value:"Example 2 \u2013 Ranking window function with an ORDER BY clause",id:"example-2--ranking-window-function-with-an-order-by-clause",level:3},{value:"Example 3 \u2013 Aggregate function over a row window frame",id:"example-3--aggregate-function-over-a-row-window-frame",level:3},{value:"Example 4 \u2013 Aggregate function for a range or groups window frame",id:"example-4--aggregate-function-for-a-range-or-groups-window-frame",level:3},{value:"Example 5 \u2013 Aggregate function for a range and a groups window frame",id:"example-5--aggregate-function-for-a-range-and-a-groups-window-frame",level:3}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"queries-with-window-functions",children:"Queries with Window Functions"}),"\n",(0,o.jsx)(n.p,{children:"Window expressions allow application developers to more easily compose complex online analytical processing (OLAP) queries using standard SQL commands. For example, with window expressions, users can calculate moving averages or sums over various intervals, reset aggregations and ranks as selected column values change, and express complex ratios in simple terms."}),"\n",(0,o.jsxs)(n.p,{children:["A window expression represents the application of a ",(0,o.jsx)(n.code,{children:"<window function>"})," to a ",(0,o.jsx)(n.code,{children:"<window frame>"}),", which is defined with an ",(0,o.jsx)(n.code,{children:"OVER()"})," clause. This is comparable to the type of calculation that can be done with an aggregate function and a ",(0,o.jsx)(n.code,{children:"GROUP BY"})," clause. Unlike aggregate functions, which return a single result value for each group of rows, window functions return a result value for every row, but that value is calculated with respect to the set of rows in the window frame to which the row belongs. The ",(0,o.jsx)(n.code,{children:"OVER()"})," clause allows dividing the rows into ",(0,o.jsx)(n.em,{children:"partitions"})," and then further restricting the window frame by specifying which rows preceding or following the current row within its partition to include in the calculation."]}),"\n",(0,o.jsx)(n.p,{children:"Apache Cloudberry does not support specifying a window function as an argument to another window function."}),"\n",(0,o.jsx)(n.p,{children:"The syntax of a window expression is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"<window_function> ( [<expression> [, ...]] ) [ FILTER ( WHERE <filter_clause> ) ] OVER ( <window_specification> )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Where ",(0,o.jsx)(n.code,{children:"<window_function>"})," might be a user-defined window function, and ",(0,o.jsx)(n.code,{children:"<expression>"})," is any value expression that does not contain a window expression, and ",(0,o.jsx)(n.code,{children:"<window_specification>"})," is:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"[<window_name>]\n[PARTITION BY <expression> [, ...]]\n[[ORDER BY <expression> [ASC | DESC | USING operator] [NULLS {FIRST | LAST}] [, ...]\n[ <frame_clause> ]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The optional ",(0,o.jsx)(n.code,{children:"<frame_clause>"})," can be one of the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"{ RANGE | ROWS | GROUPS } <frame_start> [ <frame_exclusion> ]\n{ RANGE | ROWS | GROUPS } BETWEEN <frame_start> AND <frame_end> [ <frame_exclusion> ]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Where ",(0,o.jsx)(n.code,{children:"<frame_start>"})," and ",(0,o.jsx)(n.code,{children:"<frame_end>"})," can be one of the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"UNBOUNDED PRECEDING\n<offset> PRECEDING\nCURRENT ROW\n<offset> FOLLOWING\nUNBOUNDED FOLLOWING\n"})}),"\n",(0,o.jsxs)(n.p,{children:["and ",(0,o.jsx)(n.code,{children:"<frame_exclusion>"})," can be one of the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"EXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A window expression can appear only in the select list of a ",(0,o.jsx)(n.code,{children:"SELECT"})," command. For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT count(*) OVER(PARTITION BY customer_id), * FROM sales;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If ",(0,o.jsx)(n.code,{children:"FILTER"})," is specified, then only the input rows for which the ",(0,o.jsx)(n.code,{children:"<filter_clause>"})," evaluates to true are fed to the window function; other rows are discarded. In a window expression, a ",(0,o.jsx)(n.code,{children:"FILTER"})," clause can be used only with a ",(0,o.jsx)(n.code,{children:"<window_function>"})," that is an aggregate function."]}),"\n",(0,o.jsxs)(n.p,{children:["In a window expression, the expression must contain an ",(0,o.jsx)(n.code,{children:"OVER"})," clause. The ",(0,o.jsx)(n.code,{children:"OVER"})," clause specifies the window frame\u2014the rows to be processed by the window function. This syntactically distinguishes the function from a regular or aggregate function."]}),"\n",(0,o.jsxs)(n.p,{children:["In a window aggregate function that is used in a window expression, Apache Cloudberry does not support a ",(0,o.jsx)(n.code,{children:"DISTINCT"})," clause with multiple input expressions."]}),"\n",(0,o.jsx)(n.p,{children:"A window specification has the following characteristics:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"PARTITION BY"})," clause defines the window partitions to which the window function is applied. If omitted, the entire result set is treated as one partition."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause defines the expression(s) for sorting rows within a window partition. The ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause of a window specification is separate and distinct from the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause of a regular query expression. The ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause is required for the window functions that calculate rankings, as it identifies the measure(s) for the ranking values. For OLAP aggregations, the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause is required to use window frames (the ",(0,o.jsx)(n.code,{children:"ROWS"}),", ",(0,o.jsx)(n.code,{children:"RANGE"})," or ",(0,o.jsx)(n.code,{children:"GROUPS"})," clause)."]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["Columns of data types without a coherent ordering, such as ",(0,o.jsx)(n.code,{children:"time"}),", are not good candidates for use in the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause of a window specification. ",(0,o.jsx)(n.code,{children:"Time"}),", with or without a specified time zone, lacks a coherent ordering because addition and subtraction do not have the expected effects. For example, the following is not generally true: ",(0,o.jsx)(n.code,{children:"x::time < x::time + '2 hour'::interval"})]})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"<frame_clause>"})," specifies the set of rows constituting the ",(0,o.jsx)(n.code,{children:"<window frame>"}),", which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in ",(0,o.jsx)(n.code,{children:"RANGE"}),", ",(0,o.jsx)(n.code,{children:"ROWS"})," or ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode; in each case, it runs from the ",(0,o.jsx)(n.code,{children:"<frame_start>"})," to the ",(0,o.jsx)(n.code,{children:"<frame_end>"}),". If ",(0,o.jsx)(n.code,{children:"<frame_end>"})," is omitted, the end defaults to ",(0,o.jsx)(n.code,{children:"CURRENT ROW"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"<frame_start>"})," of ",(0,o.jsx)(n.code,{children:"UNBOUNDED PRECEDING"})," means that the frame starts with the first row of the partition, and similarly a ",(0,o.jsx)(n.code,{children:"<frame_end>"})," of ",(0,o.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"})," means that the frame ends with the last row of the partition."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"RANGE"})," or ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode, a ",(0,o.jsx)(n.code,{children:"<frame_start>"})," of ",(0,o.jsx)(n.code,{children:"CURRENT ROW"})," means the frame starts with the current row's first peer row (a row that the window's ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause sorts as equivalent to the current row), while a ",(0,o.jsx)(n.code,{children:"<frame_end>"})," of ",(0,o.jsx)(n.code,{children:"CURRENT ROW"})," means the frame ends with the current row's last peer row. In ",(0,o.jsx)(n.code,{children:"ROWS"})," mode, ",(0,o.jsx)(n.code,{children:"CURRENT ROW"})," simply means the current row."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["In the ",(0,o.jsx)(n.code,{children:"<offset> PRECEDING"})," and ",(0,o.jsx)(n.code,{children:"<offset> FOLLOWING"})," frame options, the ",(0,o.jsx)(n.code,{children:"<offset>"})," must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the ",(0,o.jsx)(n.code,{children:"<offset>"})," depends on the frame mode:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"ROWS"})," mode, the ",(0,o.jsx)(n.code,{children:"<offset>"})," must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode, the ",(0,o.jsx)(n.code,{children:"<offset>"})," again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of peer groups before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," ordering. (There must be an ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause in the window definition to use ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode)."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"RANGE"})," mode, these options require that the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause specifies exactly one column. The ",(0,o.jsx)(n.code,{children:"<offset>"})," specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the ",(0,o.jsx)(n.code,{children:"<offset>"})," expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an ",(0,o.jsx)(n.code,{children:"interval"}),". For example, if the ordering column is of type ",(0,o.jsx)(n.code,{children:"date"})," or ",(0,o.jsx)(n.code,{children:"timestamp"}),", one could write ",(0,o.jsx)(n.code,{children:"RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING"}),". The ",(0,o.jsx)(n.code,{children:"<offset>"})," is still required to be non-null and non-negative, though the meaning of \u201cnon-negative\u201d depends on its data type."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Notice that in both ",(0,o.jsx)(n.code,{children:"ROWS"})," and ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode, ",(0,o.jsx)(n.code,{children:"0 PRECEDING"})," and ",(0,o.jsx)(n.code,{children:"0 FOLLOWING"})," are equivalent to ",(0,o.jsx)(n.code,{children:"CURRENT ROW"}),". This normally holds in ",(0,o.jsx)(n.code,{children:"RANGE"})," mode as well, for an appropriate data-type-specific meaning of \u201czero\u201d."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"<frame_exclusion>"})," option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. ",(0,o.jsx)(n.code,{children:"EXCLUDE CURRENT ROW"})," excludes the current row from the frame. ",(0,o.jsx)(n.code,{children:"EXCLUDE GROUP"})," excludes the current row and its ordering peers from the frame. ",(0,o.jsx)(n.code,{children:"EXCLUDE TIES"})," excludes any peers of the current row from the frame, but not the current row itself. ",(0,o.jsx)(n.code,{children:"EXCLUDE NO OTHERS"})," simply specifies explicitly the default behavior of not excluding the current row or its peers."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The default framing option is ",(0,o.jsx)(n.code,{children:"RANGE UNBOUNDED PRECEDING"}),", which is the same as ",(0,o.jsx)(n.code,{children:"RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"}),". With ",(0,o.jsx)(n.code,{children:"ORDER BY"}),", this sets the frame to be all rows from the partition start up through the current row's last ",(0,o.jsx)(n.code,{children:"ORDER BY"})," peer. Without ",(0,o.jsx)(n.code,{children:"ORDER BY"}),", this means all rows of the partition are included in the window frame, because all rows become peers of the current row."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Restrictions are that ",(0,o.jsx)(n.code,{children:"<frame_start>"})," cannot be ",(0,o.jsx)(n.code,{children:"UNBOUNDED FOLLOWING"}),", ",(0,o.jsx)(n.code,{children:"<frame_end>"})," cannot be ",(0,o.jsx)(n.code,{children:"UNBOUNDED PRECEDING"}),", and the ",(0,o.jsx)(n.code,{children:"<frame_end>"})," choice cannot appear earlier in the above list than the ",(0,o.jsx)(n.code,{children:"<frame_start>"})," choice. for example ",(0,o.jsx)(n.code,{children:"RANGE BETWEEN CURRENT ROW AND value PRECEDING"})," is not allowed."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"window-examples",children:"Window examples"}),"\n",(0,o.jsx)(n.p,{children:"The following examples demonstrate using window functions with partitions and window frames."}),"\n",(0,o.jsx)(n.h3,{id:"example-1--aggregate-window-function-over-a-partition",children:"Example 1 \u2013 Aggregate window function over a partition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"PARTITION BY"})," list in the ",(0,o.jsx)(n.code,{children:"OVER"})," clause divides the rows into groups, or partitions, that have the same values as the specified expressions."]}),"\n",(0,o.jsx)(n.p,{children:"This example compares employees' salaries with the average salaries for their departments:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary, avg(salary) OVER(PARTITION BY depname)\nFROM empsalary;\n  depname  | empno | salary |          avg          \n-----------+-------+--------+-----------------------\n develop   |     9 |   4500 | 5020.0000000000000000\n develop   |    10 |   5200 | 5020.0000000000000000\n develop   |    11 |   5200 | 5020.0000000000000000\n develop   |     7 |   4200 | 5020.0000000000000000\n develop   |     8 |   6000 | 5020.0000000000000000\n personnel |     5 |   3500 | 3700.0000000000000000\n personnel |     2 |   3900 | 3700.0000000000000000\n sales     |     1 |   5000 | 4866.6666666666666667\n sales     |     3 |   4800 | 4866.6666666666666667\n sales     |     4 |   4800 | 4866.6666666666666667\n(10 rows)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The first three output columns come from the table ",(0,o.jsx)(n.code,{children:"empsalary"}),", and there is one output row for each row in the table. The fourth column is the average calculated on all rows that have the same ",(0,o.jsx)(n.code,{children:"depname"})," value as the current row. Rows that share the same ",(0,o.jsx)(n.code,{children:"depname"})," value constitute a partition, and there are three partitions in this example. The ",(0,o.jsx)(n.code,{children:"avg"})," function is the same as the regular ",(0,o.jsx)(n.code,{children:"avg"})," aggregate function, but the ",(0,o.jsx)(n.code,{children:"OVER"})," clause causes it to be applied as a window function."]}),"\n",(0,o.jsxs)(n.p,{children:["You can also put the window specification in a ",(0,o.jsx)(n.code,{children:"WINDOW"})," clause and reference it in the select list. This example is equivalent to the previous query:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary, avg(salary) OVER(mywindow)\nFROM empsalary\nWINDOW mywindow AS (PARTITION BY depname);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Defining a named window is useful when the select list has multiple window functions using the same window specification."}),"\n",(0,o.jsx)(n.h3,{id:"example-2--ranking-window-function-with-an-order-by-clause",children:"Example 2 \u2013 Ranking window function with an ORDER BY clause"}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause within the ",(0,o.jsx)(n.code,{children:"OVER"})," clause controls the order in which rows are processed by window functions. The ",(0,o.jsx)(n.code,{children:"ORDER BY"})," list for the window function does not have to match the output order of the query. This example uses the ",(0,o.jsx)(n.code,{children:"rank()"})," window function to rank employees' salaries within their departments:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary,\n    rank() OVER (PARTITION BY depname ORDER BY salary DESC)\nFROM empsalary;\n  depname  | empno | salary | rank \n-----------+-------+--------+------\n develop   |     8 |   6000 |    1\n develop   |    11 |   5200 |    2\n develop   |    10 |   5200 |    2\n develop   |     9 |   4500 |    4\n develop   |     7 |   4200 |    5\n personnel |     2 |   3900 |    1\n personnel |     5 |   3500 |    2\n sales     |     1 |   5000 |    1\n sales     |     4 |   4800 |    2\n sales     |     3 |   4800 |    2\n(10 rows)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-3--aggregate-function-over-a-row-window-frame",children:"Example 3 \u2013 Aggregate function over a row window frame"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"RANGE"}),", ",(0,o.jsx)(n.code,{children:"ROWS"})," or ",(0,o.jsx)(n.code,{children:"GROUPS"})," clause defines the window frame\u2014a set of rows within a partition\u2014that the window function includes in the calculation. ",(0,o.jsx)(n.code,{children:"ROWS"})," specifies a physical set of rows to process, for example all rows from the beginning of the partition to the current row."]}),"\n",(0,o.jsxs)(n.p,{children:["This example calculates a running total of employee's salaries by department using the ",(0,o.jsx)(n.code,{children:"sum()"})," function to total rows from the start of the partition to the current row:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary,\n    sum(salary) OVER (PARTITION BY depname ORDER BY salary\n        ROWS between UNBOUNDED PRECEDING AND CURRENT ROW)\nFROM empsalary ORDER BY depname, sum;\n  depname  | empno | salary |  sum  \n-----------+-------+--------+-------\n develop   |     7 |   4200 |  4200\n develop   |     9 |   4500 |  8700\n develop   |    11 |   5200 | 13900\n develop   |    10 |   5200 | 19100\n develop   |     8 |   6000 | 25100\n personnel |     5 |   3500 |  3500\n personnel |     2 |   3900 |  7400\n sales     |     4 |   4800 |  4800\n sales     |     3 |   4800 |  9600\n sales     |     1 |   5000 | 14600\n(10 rows)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-4--aggregate-function-for-a-range-or-groups-window-frame",children:"Example 4 \u2013 Aggregate function for a range or groups window frame"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"RANGE"})," and ",(0,o.jsx)(n.code,{children:"GROUPS"})," modes specify logical values based on values of the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," expression in the ",(0,o.jsx)(n.code,{children:"OVER"})," clause. This example demonstrates the difference between ",(0,o.jsx)(n.code,{children:"ROWS"})," and ",(0,o.jsx)(n.code,{children:"RANGE"})," or ",(0,o.jsx)(n.code,{children:"GROUPS"}),". The frame contains all rows with salary values less than or equal to the current row. Unlike the previous example, for employees with the same salary, the sum is the same and includes the salaries of all of those employees."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary,\n    sum(salary) OVER (PARTITION BY depname ORDER BY salary\n        RANGE between UNBOUNDED PRECEDING AND CURRENT ROW)\nFROM empsalary ORDER BY depname, sum;\n  depname  | empno | salary |  sum  \n-----------+-------+--------+-------\n develop   |     7 |   4200 |  4200\n develop   |     9 |   4500 |  8700\n develop   |    11 |   5200 | 19100\n develop   |    10 |   5200 | 19100\n develop   |     8 |   6000 | 25100\n personnel |     5 |   3500 |  3500\n personnel |     2 |   3900 |  7400\n sales     |     4 |   4800 |  9600\n sales     |     3 |   4800 |  9600\n sales     |     1 |   5000 | 14600\n(10 rows)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, because the ",(0,o.jsx)(n.code,{children:"<frame_start>"})," and ",(0,o.jsx)(n.code,{children:"<frame_end>"})," are not using an ",(0,o.jsx)(n.code,{children:"<offset>"}),", ",(0,o.jsx)(n.code,{children:"RANGE"})," and ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode provide identical results:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT depname, empno, salary,\n    sum(salary) OVER (PARTITION BY depname ORDER BY salary\n        GROUPS between UNBOUNDED PRECEDING AND CURRENT ROW)\nFROM empsalary ORDER BY depname, sum;\n  depname  | empno | salary |  sum\n-----------+-------+--------+-------\n develop   |     7 |   4200 |  4200\n develop   |     9 |   4500 |  8700\n develop   |    11 |   5200 | 19100\n develop   |    10 |   5200 | 19100\n develop   |     8 |   6000 | 25100\n personnel |     5 |   3500 |  3500\n personnel |     2 |   3900 |  7400\n sales     |     4 |   4800 |  9600\n sales     |     3 |   4800 |  9600\n sales     |     1 |   5000 | 14600\n(10 rows)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-5--aggregate-function-for-a-range-and-a-groups-window-frame",children:"Example 5 \u2013 Aggregate function for a range and a groups window frame"}),"\n",(0,o.jsxs)(n.p,{children:["This example demonstrates the difference between ",(0,o.jsx)(n.code,{children:"RANGE"})," and ",(0,o.jsx)(n.code,{children:"GROUPS"}),". The table ",(0,o.jsx)(n.code,{children:"sales"})," lists the sales a company's two shops during a period of four days."]}),"\n",(0,o.jsxs)(n.p,{children:["When using ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode, the value of ",(0,o.jsx)(n.code,{children:"<offset>"})," indicates the number of peer groups before the current row's peer group. The different peer groups are set by the ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause, in this case the date. because the query does not specify a value for ",(0,o.jsx)(n.code,{children:"<frame_end>"}),", the end defaults to ",(0,o.jsx)(n.code,{children:"CURRENT ROW"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT date, shop, total, sum(total) OVER (PARTITION BY shop ORDER BY date asc GROUPS 2 PRECEDING) \nFROM sales ORDER BY shop, date;\n    date    |  shop  |  total  |   sum    \n------------+--------+---------+----------\n 2022-01-07 | Shop 1 | 3000.00 |  3000.00\n 2022-01-08 | Shop 1 | 1000.00 |  4000.00\n 2022-01-09 | Shop 1 | 5000.00 | 11000.00\n 2022-01-09 | Shop 1 | 2000.00 | 11000.00\n 2022-01-07 | Shop 2 | 4000.00 | 10000.00\n 2022-01-07 | Shop 2 | 6000.00 | 10000.00\n 2022-01-09 | Shop 2 | 7000.00 | 21000.00\n 2022-01-09 | Shop 2 | 4000.00 | 21000.00\n 2022-01-10 | Shop 2 | 2000.00 | 23000.00\n(9 rows)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In order to get the equivalent result when using the ",(0,o.jsx)(n.code,{children:"RANGE"})," mode, the ",(0,o.jsx)(n.code,{children:"<frame_clause>"})," must specify an ",(0,o.jsx)(n.code,{children:"<offset>"})," using the same data type as the ordering column, in this case ",(0,o.jsx)(n.code,{children:"date"}),". Using the numberic value ",(0,o.jsx)(n.code,{children:"2"})," will return an error."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT date, shop, total, sum(total) OVER (PARTITION BY shop ORDER BY date asc RANGE '2 days' PRECEDING) \nFROM sales ORDER BY shop, date;\n    date    |  shop  |  total  |   sum    \n------------+--------+---------+----------\n 2022-01-07 | Shop 1 | 3000.00 |  3000.00\n 2022-01-08 | Shop 1 | 1000.00 |  4000.00\n 2022-01-09 | Shop 1 | 5000.00 | 11000.00\n 2022-01-09 | Shop 1 | 2000.00 | 11000.00\n 2022-01-07 | Shop 2 | 4000.00 | 10000.00\n 2022-01-07 | Shop 2 | 6000.00 | 10000.00\n 2022-01-09 | Shop 2 | 7000.00 | 21000.00\n 2022-01-09 | Shop 2 | 4000.00 | 21000.00\n 2022-01-10 | Shop 2 | 2000.00 | 13000.00\n(9 rows)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the above outputs differ in the last row because ",(0,o.jsx)(n.code,{children:"RANGE"})," mode uses the entries from the previous two days and there is no entry for ",(0,o.jsx)(n.code,{children:"2022-01-08"})," for Shop 2, but ",(0,o.jsx)(n.code,{children:"GROUPS"})," mode uses the previous two peer groups, which are ",(0,o.jsx)(n.code,{children:"2022-01-07"})," and ",(0,o.jsx)(n.code,{children:"2022-01-09"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>a});var o=s(67294);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);
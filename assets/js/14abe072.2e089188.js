"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[6821],{70861:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>l});var o=i(85893),a=i(11151);const n={title:"Collect Root Partition Statistics"},r="Collect Root Partition Statistics",s={id:"performance/optimize-queries/use-orca/gporca-collect-root-partition-stats",title:"Collect Root Partition Statistics",description:"For a partitioned table, GPORCA uses statistics of the table root partition to generate query plans. These statistics are used for determining the join order, for splitting and joining aggregate nodes, and for costing the query steps. In contrast, the Postgres-based planner uses the statistics of each leaf partition.",source:"@site/docs/performance/optimize-queries/use-orca/gporca-collect-root-partition-stats.md",sourceDirName:"performance/optimize-queries/use-orca",slug:"/performance/optimize-queries/use-orca/gporca-collect-root-partition-stats",permalink:"/docs/next/performance/optimize-queries/use-orca/gporca-collect-root-partition-stats",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/performance/optimize-queries/use-orca/gporca-collect-root-partition-stats.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756809586,formattedLastUpdatedAt:"Sep 2, 2025",frontMatter:{title:"Collect Root Partition Statistics"},sidebar:"docsbars",previous:{title:"GPORCA Optimizer Update Notes",permalink:"/docs/next/performance/optimize-queries/use-orca/whats-new-in-orca"},next:{title:"GPORCA Limitations",permalink:"/docs/next/performance/optimize-queries/use-orca/gporca-limitations"}},c={},l=[{value:"Run ANALYZE",id:"run-analyze",level:2},{value:"GPORCA and leaf partition statistics",id:"gporca-and-leaf-partition-statistics",level:2},{value:"Deactivate automatic root partition statistics collection",id:"deactivate-automatic-root-partition-statistics-collection",level:2}];function d(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"collect-root-partition-statistics",children:"Collect Root Partition Statistics"}),"\n",(0,o.jsx)(e.p,{children:"For a partitioned table, GPORCA uses statistics of the table root partition to generate query plans. These statistics are used for determining the join order, for splitting and joining aggregate nodes, and for costing the query steps. In contrast, the Postgres-based planner uses the statistics of each leaf partition."}),"\n",(0,o.jsx)(e.p,{children:"If you run queries on partitioned tables, you should collect statistics on the root partition and periodically update those statistics to ensure that GPORCA can generate optimal query plans. If the root partition statistics are not up-to-date or do not exist, GPORCA still performs dynamic partition elimination for queries against the table. However, the query plan might not be optimal."}),"\n",(0,o.jsx)(e.h2,{id:"run-analyze",children:"Run ANALYZE"}),"\n",(0,o.jsxs)(e.p,{children:["By default, running the ",(0,o.jsx)(e.code,{children:"ANALYZE"})," command on a root partitioned table samples the leaf partition data in the table, and stores the statistics for the root partition. ",(0,o.jsx)(e.code,{children:"ANALYZE"})," collects statistics on the root and leaf partitions, including HyperLogLog (HLL) statistics on the leaf partitions. ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION"})," collects statistics only on the root partition. The server configuration parameter ",(0,o.jsx)(e.code,{children:"optimizer_analyze_root_partition"})," controls whether the ",(0,o.jsx)(e.code,{children:"ROOTPARTITION"})," keyword is required to collect root statistics for a root partitioned table. See the ",(0,o.jsx)(e.a,{href:"/docs/next/sql-stmts/analyze",children:(0,o.jsx)(e.code,{children:"ANALYZE"})})," command for information about collecting statistics on partitioned tables."]}),"\n",(0,o.jsxs)(e.p,{children:["Keep in mind that ",(0,o.jsx)(e.code,{children:"ANALYZE"})," always scans the entire table before updating the root partition statistics. If your table is very large, this operation can take a significant amount of time. ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION"})," also uses an ",(0,o.jsx)(e.code,{children:"ACCESS SHARE"})," lock that prevents certain operations, such as ",(0,o.jsx)(e.code,{children:"TRUNCATE"})," and ",(0,o.jsx)(e.code,{children:"VACUUM"})," operations, during runtime. For these reasons, you should schedule ",(0,o.jsx)(e.code,{children:"ANALYZE"})," operations periodically, or when there are significant changes to leaf partition data."]}),"\n",(0,o.jsxs)(e.p,{children:["Follow these best practices for running ",(0,o.jsx)(e.code,{children:"ANALYZE"})," or ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION"})," on partitioned tables in your system:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Run ",(0,o.jsx)(e.code,{children:"ANALYZE <root_partition_table_name>"})," on a new partitioned table after adding initial data. Run ",(0,o.jsx)(e.code,{children:"ANALYZE <leaf_partition_table_name>"})," on a new leaf partition or a leaf partition where data has changed. By default, running the command on a leaf partition updates the root partition statistics if the other leaf partitions have statistics."]}),"\n",(0,o.jsxs)(e.li,{children:["Update root partition statistics when you observe query performance regression in ",(0,o.jsx)(e.code,{children:"EXPLAIN"})," plans against the table, or after significant changes to leaf partition data. For example, if you add a new leaf partition at some point after generating root partition statistics, consider running ",(0,o.jsx)(e.code,{children:"ANALYZE"})," or ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION"})," to update root partition statistics with the new tuples inserted from the new leaf partition."]}),"\n",(0,o.jsxs)(e.li,{children:["For very large tables, run ",(0,o.jsx)(e.code,{children:"ANALYZE"})," or ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION"})," only weekly, or at some interval longer than daily."]}),"\n",(0,o.jsxs)(e.li,{children:["Avoid running ",(0,o.jsx)(e.code,{children:"ANALYZE"})," with no arguments, because doing so runs the command on all database tables including partitioned tables. With large databases, these global ",(0,o.jsx)(e.code,{children:"ANALYZE"})," operations are difficult to monitor, and it can be difficult to predict the time needed for completion."]}),"\n",(0,o.jsxs)(e.li,{children:["Consider running multiple ",(0,o.jsx)(e.code,{children:"ANALYZE <table_name>"})," or ",(0,o.jsx)(e.code,{children:"ANALYZE ROOTPARTITION <table_name>"})," operations in parallel to speed the operation of statistics collection, if your I/O throughput can support the load."]}),"\n",(0,o.jsxs)(e.li,{children:["You can also use the Apache Cloudberry utility ",(0,o.jsx)(e.code,{children:"analyzedb"})," to update table statistics. Using ",(0,o.jsx)(e.code,{children:"analyzedb"})," ensures that tables that were previously analyzed are not re-analyzed if no modifications were made to the leaf partition."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"gporca-and-leaf-partition-statistics",children:"GPORCA and leaf partition statistics"}),"\n",(0,o.jsx)(e.p,{children:"Although creating and maintaining root partition statistics is crucial for GPORCA query performance with partitioned tables, maintaining leaf partition statistics is also important. If GPORCA cannot generate a plan for a query against a partitioned table, then the Postgres-based planner is used and leaf partition statistics are needed to produce the optimal plan for that query."}),"\n",(0,o.jsx)(e.p,{children:"GPORCA itself also uses leaf partition statistics for any queries that access leaf partitions directly, instead of using the root partition with predicates to eliminate partitions. For example, if you know which partitions hold necessary tuples for a query, you can directly query the leaf partition itself; in this case GPORCA uses the leaf partition statistics."}),"\n",(0,o.jsx)(e.h2,{id:"deactivate-automatic-root-partition-statistics-collection",children:"Deactivate automatic root partition statistics collection"}),"\n",(0,o.jsxs)(e.p,{children:["If you do not intend to run queries on partitioned tables with GPORCA (setting the server configuration parameter ",(0,o.jsx)(e.code,{children:"optimizer"})," to ",(0,o.jsx)(e.code,{children:"off"}),"), then you can deactivate the automatic collection of statistics on the root partition of the partitioned table. The server configuration parameter ",(0,o.jsx)(e.code,{children:"optimizer_analyze_root_partition"})," controls whether the ",(0,o.jsx)(e.code,{children:"ROOTPARTITION"})," keyword is required to collect root statistics for a root partitioned table. The default setting for the parameter is ",(0,o.jsx)(e.code,{children:"on"}),", the ",(0,o.jsx)(e.code,{children:"ANALYZE"})," command can collect root partition statistics without the ",(0,o.jsx)(e.code,{children:"ROOTPARTITION"})," keyword. You can deactivate automatic collection of root partition statistics by setting the parameter to ",(0,o.jsx)(e.code,{children:"off"}),". When the value is ",(0,o.jsx)(e.code,{children:"off"}),", you must run ",(0,o.jsx)(e.code,{children:"ANALZYE ROOTPARTITION"})," to collect root partition statistics."]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["Log into the Apache Cloudberry coordinator host as ",(0,o.jsx)(e.code,{children:"gpadmin"}),", the Apache Cloudberry administrator."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["Set the values of the server configuration parameters. These Apache Cloudberry ",(0,o.jsx)(e.code,{children:"gpconfig"})," utility commands sets the value of the parameters to ",(0,o.jsx)(e.code,{children:"off"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-shell",children:"$ gpconfig -c optimizer_analyze_root_partition -v off --coordinatoronly\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["Restart Apache Cloudberry. This Apache Cloudberry ",(0,o.jsx)(e.code,{children:"gpstop"})," utility command reloads the ",(0,o.jsx)(e.code,{children:"postgresql.conf"})," files of the coordinator and segments without shutting down Apache Cloudberry."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-shell",children:"gpstop -u\n"})}),"\n"]}),"\n"]})]})}function h(t={}){const{wrapper:e}={...(0,a.a)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(d,{...t})}):d(t)}},11151:(t,e,i)=>{i.d(e,{Z:()=>s,a:()=>r});var o=i(67294);const a={},n=o.createContext(a);function r(t){const e=o.useContext(n);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:r(t.components),o.createElement(n.Provider,{value:e},t.children)}}}]);
"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[56943],{78328:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(85893),t=n(11151);const r={title:"Value Expressions"},i="Value Expressions",o={id:"operate-with-data/sql-queries/value-expressions",title:"Value Expressions",description:"Value expressions are the core components that allow you to calculate, transform, and reference data within a query. When defining queries, understanding these expressions is key to writing flexible and effective SQL.",source:"@site/versioned_docs/version-2.x/operate-with-data/sql-queries/value-expressions.md",sourceDirName:"operate-with-data/sql-queries",slug:"/operate-with-data/sql-queries/value-expressions",permalink:"/docs/operate-with-data/sql-queries/value-expressions",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/sql-queries/value-expressions.md",tags:[],version:"2.x",lastUpdatedBy:"TomShawn",lastUpdatedAt:1749026520,formattedLastUpdatedAt:"Jun 4, 2025",frontMatter:{title:"Value Expressions"},sidebar:"docsbars",previous:{title:"Expression Evaluation Rules",permalink:"/docs/operate-with-data/sql-queries/evaluation-order"},next:{title:"Queries with Aggregate Expressions",permalink:"/docs/operate-with-data/sql-queries/aggregates-expressions"}},l={},c=[{value:"Column references",id:"column-references",level:2},{value:"Positional parameters",id:"positional-parameters",level:2},{value:"Subscripts",id:"subscripts",level:2},{value:"Field selection",id:"field-selection",level:2},{value:"Operator invocations",id:"operator-invocations",level:2},{value:"Function calls",id:"function-calls",level:2},{value:"Type casts",id:"type-casts",level:2},{value:"Array constructors",id:"array-constructors",level:2},{value:"Row constructors",id:"row-constructors",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.h1,{id:"value-expressions",children:"Value Expressions"}),"\n",(0,a.jsx)(s.p,{children:"Value expressions are the core components that allow you to calculate, transform, and reference data within a query. When defining queries, understanding these expressions is key to writing flexible and effective SQL."}),"\n",(0,a.jsx)(s.p,{children:"This document explains  types of expressions such as column references, positional parameters, array and row constructors, function calls, and type casts. Each type plays a specific role in how data is processed and represented in a query result."}),"\n",(0,a.jsx)(s.h2,{id:"column-references",children:"Column references"}),"\n",(0,a.jsx)(s.p,{children:"A column reference has the form:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<correlation>.<columnname>\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Here, ",(0,a.jsx)(s.code,{children:"<correlation>"})," is the name of a table (possibly qualified with a schema name) or an alias for a table defined with a ",(0,a.jsx)(s.code,{children:"FROM"})," clause or one of the keywords ",(0,a.jsx)(s.code,{children:"NEW"})," or ",(0,a.jsx)(s.code,{children:"OLD"}),". ",(0,a.jsx)(s.code,{children:"NEW"})," and ",(0,a.jsx)(s.code,{children:"OLD"})," can appear only in rewrite rules, but you can use other correlation names in any SQL statement. If the column name is unique across all tables in the query, you can omit the ",(0,a.jsx)(s.code,{children:"<correlation>"})," part of the column reference."]}),"\n",(0,a.jsx)(s.h2,{id:"positional-parameters",children:"Positional parameters"}),"\n",(0,a.jsxs)(s.p,{children:["Positional parameters are arguments to SQL statements or functions that you reference by their positions in a series of arguments. For example, ",(0,a.jsx)(s.code,{children:"$1"})," refers to the first argument, ",(0,a.jsx)(s.code,{children:"$2"})," to the second argument, and so on. The values of positional parameters are set from arguments external to the SQL statement or supplied when SQL functions are invoked. Some client libraries support specifying data values separately from the SQL command, in which case parameters refer to the out-of-line data values. A parameter reference has the form:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"$number\n"})}),"\n",(0,a.jsx)(s.p,{children:"For example:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"CREATE FUNCTION dept(text) RETURNS dept\n    AS $$ SELECT * FROM dept WHERE name = $1 $$\n    LANGUAGE SQL;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Here, the ",(0,a.jsx)(s.code,{children:"$1"})," references the value of the first function argument whenever the function is invoked."]}),"\n",(0,a.jsx)(s.h2,{id:"subscripts",children:"Subscripts"}),"\n",(0,a.jsx)(s.p,{children:"If an expression yields a value of an array type, you can extract a specific element of the array value as follows:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<expression>[<subscript>]\n\n"})}),"\n",(0,a.jsx)(s.p,{children:"You can extract multiple adjacent elements, called an array slice, as follows (including the brackets):"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<expression>[<lower_subscript>:<upper_subscript>]\n\n"})}),"\n",(0,a.jsx)(s.p,{children:"Each subscript is an expression and yields an integer value."}),"\n",(0,a.jsx)(s.p,{children:"Array expressions usually must be in parentheses, but you can omit the parentheses when the expression to be subscripted is a column reference or positional parameter. You can concatenate multiple subscripts when the original array is multidimensional. For example (including the parentheses):"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"mytable.arraycolumn[4]\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"mytable.two_d_column[17][34]\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"$1[10:42]\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"(arrayfunction(a,b))[42]\n"})}),"\n",(0,a.jsx)(s.h2,{id:"field-selection",children:"Field selection"}),"\n",(0,a.jsx)(s.p,{children:"If an expression yields a value of a composite type (row type), you can extract a specific field of the row as follows:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<expression>.<fieldname>\n"})}),"\n",(0,a.jsx)(s.p,{children:"The row expression usually must be in parentheses, but you can omit these parentheses when the expression to be selected from is a table reference or positional parameter. For example:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"mytable.mycolumn\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"$1.somecolumn\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"(rowfunction(a,b)).col3\n"})}),"\n",(0,a.jsx)(s.p,{children:"A qualified column reference is a special case of field selection syntax."}),"\n",(0,a.jsx)(s.h2,{id:"operator-invocations",children:"Operator invocations"}),"\n",(0,a.jsx)(s.p,{children:"Operator invocations have the following possible syntaxes:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<expression operator expression>(binary infix operator)\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<operator expression>(unary prefix operator)\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"<expression operator>(unary postfix operator)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Where ",(0,a.jsx)(s.code,{children:"operator"})," is an operator token, one of the key words ",(0,a.jsx)(s.code,{children:"AND"}),", ",(0,a.jsx)(s.code,{children:"OR"}),", or ",(0,a.jsx)(s.code,{children:"NOT"}),", or qualified operator name in the form:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"OPERATOR(<schema>.<operatorname>)\n"})}),"\n",(0,a.jsx)(s.p,{children:"Available operators and whether they are unary or binary depends on the operators that the system or user defines."}),"\n",(0,a.jsx)(s.h2,{id:"function-calls",children:"Function calls"}),"\n",(0,a.jsx)(s.p,{children:"The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"function ([expression [, expression ... ]])\n"})}),"\n",(0,a.jsx)(s.p,{children:"For example, the following function call computes the square root of 2:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"sqrt(2)\n"})}),"\n",(0,a.jsx)(s.h2,{id:"type-casts",children:"Type casts"}),"\n",(0,a.jsx)(s.p,{children:"A type cast specifies a conversion from one data type to another. A cast applied to a value expression of a known type is a run-time type conversion. The cast succeeds only if a suitable type conversion is defined. This differs from the use of casts with constants. A cast applied to a string literal represents the initial assignment of a type to a literal constant value, so it succeeds for any type if the contents of the string literal are acceptable input syntax for the data type."}),"\n",(0,a.jsx)(s.p,{children:"Apache Cloudberry supports three types of casts applied to a value expression:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.em,{children:"Explicit cast"})," - Apache Cloudberry applies a cast when you explicitly specify a cast between two data types. Apache Cloudberry accepts two equivalent syntaxes for explicit type casts:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"CAST ( expression AS type )\nexpression::type\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"CAST"})," syntax conforms to SQL; the syntax using ",(0,a.jsx)(s.code,{children:"::"})," is historical PostgreSQL usage."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.em,{children:"Assignment cast"})," - Apache Cloudberry implicitly invokes a cast in assignment contexts, when assigning a value to a column of the target data type. For example, a ",(0,a.jsx)(s.a,{href:"/docs/sql-stmts/create-cast",children:(0,a.jsx)(s.code,{children:"CREATE CAST"})})," command with the ",(0,a.jsx)(s.code,{children:"AS ASSIGNMENT"})," clause creates a cast that is applied implicitly in the assignment context. This example assignment cast assumes that ",(0,a.jsx)(s.code,{children:"tbl1.f1"})," is a column of type ",(0,a.jsx)(s.code,{children:"text"}),". The ",(0,a.jsx)(s.code,{children:"INSERT"})," command is allowed because the value is implicitly cast from the ",(0,a.jsx)(s.code,{children:"integer"})," to ",(0,a.jsx)(s.code,{children:"text"})," type."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"INSERT INTO tbl1 (f1) VALUES (42);\n"})}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.em,{children:"Implicit cast"})," - Apache Cloudberry implicitly invokes a cast in assignment or expression contexts. For example, a ",(0,a.jsx)(s.code,{children:"CREATE CAST"})," command with the ",(0,a.jsx)(s.code,{children:"AS IMPLICIT"})," clause creates an implicit cast, a cast that is applied implicitly in both the assignment and expression context. This example implicit cast assumes that ",(0,a.jsx)(s.code,{children:"tbl1.c1"})," is a column of type ",(0,a.jsx)(s.code,{children:"int"}),". For the calculation in the predicate, the value of ",(0,a.jsx)(s.code,{children:"c1"})," is implicitly cast from ",(0,a.jsx)(s.code,{children:"int"})," to a ",(0,a.jsx)(s.code,{children:"decimal"})," type."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM tbl1 WHERE tbl1.c2 = (4.3 + tbl1.c1) ;\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"You can usually omit an explicit type cast if there is no ambiguity about the type a value expression must produce (for example, when it is assigned to a table column); the system automatically applies a type cast. Apache Cloudberry implicitly applies casts only to casts defined with a cast context of assignment or explicit in the system catalogs. Other casts must be invoked with explicit casting syntax to prevent unexpected conversions from being applied without the user's knowledge."}),"\n",(0,a.jsxs)(s.p,{children:["You can display cast information with the ",(0,a.jsx)(s.code,{children:"psql"})," meta-command ",(0,a.jsx)(s.code,{children:"dC"}),". Cast information is stored in the catalog table ",(0,a.jsx)(s.code,{children:"pg_cast"}),", and type information is stored in the catalog table ",(0,a.jsx)(s.code,{children:"pg_type"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"array-constructors",children:"Array constructors"}),"\n",(0,a.jsxs)(s.p,{children:["An array constructor is an expression that builds an array value from values for its member elements. A simple array constructor consists of the key word ",(0,a.jsx)(s.code,{children:"ARRAY"}),", a left square bracket ",(0,a.jsx)(s.code,{children:"["}),", one or more expressions separated by commas for the array element values, and a right square bracket ",(0,a.jsx)(s.code,{children:"]"}),". For example,"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT ARRAY[1,2,3+4];\n  array\n---------\n {1,2,7}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The array element type is the common type of its member expressions, determined using the same rules as for ",(0,a.jsx)(s.code,{children:"UNION"})," or ",(0,a.jsx)(s.code,{children:"CASE"})," constructs."]}),"\n",(0,a.jsxs)(s.p,{children:["You can build multidimensional array values by nesting array constructors. In the inner constructors, you can omit the keyword ",(0,a.jsx)(s.code,{children:"ARRAY"}),". For example, the following two ",(0,a.jsx)(s.code,{children:"SELECT"})," statements produce the same result:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];\nSELECT ARRAY[[1,2],[3,4]];\n     array\n---------------\n {{1,2},{3,4}}\n"})}),"\n",(0,a.jsx)(s.p,{children:"because multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions."}),"\n",(0,a.jsxs)(s.p,{children:["Multidimensional array constructor elements are not limited to a sub-",(0,a.jsx)(s.code,{children:"ARRAY"})," construct; they are anything that produces an array of the proper kind. For example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"CREATE TABLE arr(f1 int[], f2 int[]);\nINSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], \nARRAY[[5,6],[7,8]]);\nSELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;\n                     array\n------------------------------------------------\n {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["You can construct an array from the results of a subquery. Write the array constructor with the keyword ",(0,a.jsx)(s.code,{children:"ARRAY"})," followed by a subquery in parentheses. For example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');\n                          ?column?\n-----------------------------------------------------------\n {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The subquery must return a single column. The resulting one-dimensional array has an element for each row in the subquery result, with an element type matching that of the subquery's output column. The subscripts of an array value built with ",(0,a.jsx)(s.code,{children:"ARRAY"})," always begin with ",(0,a.jsx)(s.code,{children:"1"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"row-constructors",children:"Row constructors"}),"\n",(0,a.jsx)(s.p,{children:"A row constructor is an expression that builds a row value (also called a composite value) from values for its member fields. For example,"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT ROW(1,2.5,'this is a test');\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Row constructors have the syntax ",(0,a.jsx)(s.code,{children:"rowvalue.*"}),", which expands to a list of the elements of the row value, as when you use the syntax ",(0,a.jsx)(s.code,{children:".*"})," at the top level of a ",(0,a.jsx)(s.code,{children:"SELECT"})," list. For example, if table ",(0,a.jsx)(s.code,{children:"t"})," has columns ",(0,a.jsx)(s.code,{children:"f1"})," and ",(0,a.jsx)(s.code,{children:"f2"}),", the following queries are the same:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT ROW(t.*, 42) FROM t;\nSELECT ROW(t.f1, t.f2, 42) FROM t;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["By default, the value created by a ",(0,a.jsx)(s.code,{children:"ROW"})," expression has an anonymous record type. If necessary, it can be cast to a named composite type \u2014 either the row type of a table, or a composite type created with ",(0,a.jsx)(s.code,{children:"CREATE TYPE AS"}),". To avoid ambiguity, you can explicitly cast the value if necessary. For example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"CREATE TABLE mytable(f1 int, f2 float, f3 text);\nCREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' \nLANGUAGE SQL;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["In the following query, you do not need to cast the value because there is only one ",(0,a.jsx)(s.code,{children:"getf1()"})," function and therefore no ambiguity:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT getf1(ROW(1,2.5,'this is a test'));\n getf1\n-------\n     1\nCREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);\nCREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT \n$1.f1' LANGUAGE SQL;\n"})}),"\n",(0,a.jsx)(s.p,{children:"Now we need a cast to indicate which function to call:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT getf1(ROW(1,2.5,'this is a test'));\nERROR:  function getf1(record) is not unique\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-sql",children:"SELECT getf1(ROW(1,2.5,'this is a test')::mytable);\n getf1\n-------\n     1\nSELECT getf1(CAST(ROW(11,'this is a test',2.5) AS \nmyrowtype));\n getf1\n-------\n    11\n"})}),"\n",(0,a.jsx)(s.p,{children:"You can use row constructors to build composite values to be stored in a composite-type table column or to be passed to a function that accepts a composite parameter."})]})}function h(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>o,a:()=>i});var a=n(67294);const t={},r=a.createContext(t);function i(e){const s=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);
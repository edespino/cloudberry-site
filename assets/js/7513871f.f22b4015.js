"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[18116],{858:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=a(85893),s=a(11151);const o={title:"Manage Bloat in a Database"},i="Manage Bloat in a Database",r={id:"tutorials/best-practices/manage-bloat",title:"Manage Bloat in a Database",description:"Database bloat occurs in heap tables, append-optimized tables, indexes, and system catalogs and affects database performance and disk usage. You can detect database bloat and remove it from the database.",source:"@site/docs/tutorials/best-practices/manage-bloat.md",sourceDirName:"tutorials/best-practices",slug:"/tutorials/best-practices/manage-bloat",permalink:"/docs/next/tutorials/best-practices/manage-bloat",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/tutorials/best-practices/manage-bloat.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756779972,formattedLastUpdatedAt:"Sep 2, 2025",frontMatter:{title:"Manage Bloat in a Database"},sidebar:"docsbars",previous:{title:"System Monitoring and Maintenance",permalink:"/docs/next/tutorials/best-practices/system-monitor-and-maintain-best-practices"},next:{title:"Identify and Mitigate Heap Table Performance Issues",permalink:"/docs/next/tutorials/best-practices/identify-and-mitigate-heap-table-performance-issues"}},l={},d=[{value:"About bloat",id:"about-bloat",level:2},{value:"Detect bloat",id:"detect-bloat",level:2},{value:"Remove bloat from database tables",id:"remove-bloat-from-database-tables",level:2},{value:"Remove bloat from append-optimized tables",id:"remove-bloat-from-append-optimized-tables",level:2},{value:"Remove bloat from indexes",id:"remove-bloat-from-indexes",level:2},{value:"Remove bloat from system catalogs",id:"remove-bloat-from-system-catalogs",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"manage-bloat-in-a-database",children:"Manage Bloat in a Database"}),"\n",(0,n.jsx)(t.p,{children:"Database bloat occurs in heap tables, append-optimized tables, indexes, and system catalogs and affects database performance and disk usage. You can detect database bloat and remove it from the database."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#about-bloat",children:"About Bloat"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#detect-bloat",children:"Detecting Bloat"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#remove-bloat-from-database-tables",children:"Removing Bloat from Database Tables"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#remove-bloat-from-append-optimized-tables",children:"Removing Bloat from Append-Optimized Tables"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#remove-bloat-from-indexes",children:"Removing Bloat from Indexes"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"#remove-bloat-from-system-catalogs",children:"Removing Bloat from System Catalogs"})}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"about-bloat",children:"About bloat"}),"\n",(0,n.jsx)(t.p,{children:"Database bloat is disk space that was used by a table or index and is available for reuse by the database but has not been reclaimed. Bloat is created when updating tables or indexes."}),"\n",(0,n.jsxs)(t.p,{children:["Because Apache Cloudberry heap tables use the PostgreSQL Multiversion Concurrency Control (MVCC) storage implementation, a deleted or updated row is logically deleted from the database, but a non-visible image of the row remains in the table. Moreover, if the table has an index, index entries to these non-visible rows also remain. Running ",(0,n.jsx)(t.code,{children:"VACUUM"})," marks the expired rows as free space that is available for reuse by subsequent inserts, and removes the corresponding index entries if any exist."]}),"\n",(0,n.jsx)(t.p,{children:"It is normal for tables that have frequent updates to have a small or moderate amount of expired rows and free space that will be reused as new data is added. But when the table is allowed to grow so large that active data occupies just a small fraction of the space, the table has become significantly bloated. Bloated tables require more disk storage and additional I/O that can slow down query execution. It can also slow down data ingest if a bloated table has a unique index, as uniqueness validation checks will read the aforementioned index entries."}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Important"})," It is very important to run ",(0,n.jsx)(t.code,{children:"VACUUM"})," on individual tables after large ",(0,n.jsx)(t.code,{children:"UPDATE"})," and ",(0,n.jsx)(t.code,{children:"DELETE"})," operations to avoid the necessity of ever running ",(0,n.jsx)(t.code,{children:"VACUUM FULL"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Running the ",(0,n.jsx)(t.code,{children:"VACUUM"})," command regularly on tables prevents them from growing too large. If the table does become significantly bloated, the ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," command must be used to compact the table data."]}),"\n",(0,n.jsxs)(t.p,{children:["If the free space map is not large enough to accommodate all of the expired rows, the ",(0,n.jsx)(t.code,{children:"VACUUM"})," command is unable to reclaim space for expired rows that overflowed the free space map. The disk space may only be recovered by running ",(0,n.jsx)(t.code,{children:"VACUUM FULL"}),", which locks the table, creates a new table, copies the table data to the new table, and then drops old table. This is an expensive operation that can take an exceptional amount of time to complete with a large table."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Caution"})," ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," acquires an ",(0,n.jsx)(t.code,{children:"ACCESS EXCLUSIVE"})," lock on tables. You should not run ",(0,n.jsx)(t.code,{children:"VACUUM FULL"}),". If you run ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," on tables, run it during a time when users and applications do not require access to the tables, such as during a time of low activity, or during a maintenance window."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"detect-bloat",children:"Detect bloat"}),"\n",(0,n.jsxs)(t.p,{children:["The statistics collected by the ",(0,n.jsx)(t.code,{children:"ANALYZE"})," statement can be used to calculate the expected number of disk pages required to store a table. The difference between the expected number of pages and the actual number of pages is a measure of bloat. The ",(0,n.jsx)(t.code,{children:"gp_toolkit"})," schema provides the ",(0,n.jsx)(t.a,{href:"/docs/next/sys-catalogs/gp_toolkit#gp_bloat_diag",children:(0,n.jsx)(t.code,{children:"gp_bloat_diag"})})," view that identifies table bloat by comparing the ratio of expected to actual pages. To use it, make sure statistics are up to date for all of the tables in the database, then run the following SQL:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"gpadmin=# SELECT * FROM gp_toolkit.gp_bloat_diag;\n bdirelid | bdinspname | bdirelname | bdirelpages | bdiexppages |                bdidiag                \n----------+------------+------------+-------------+-------------+---------------------------------------\n    21488 | public     | t1         |          97 |           1 | significant amount of bloat suspected\n(1 row)\n"})}),"\n",(0,n.jsx)(t.p,{children:"The results include only tables with moderate or significant bloat. Moderate bloat is reported when the ratio of actual to expected pages is greater than four and less than ten. Significant bloat is reported when the ratio is greater than ten."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"gp_toolkit.gp_bloat_expected_pages"})," view lists the actual number of used pages and expected number of used pages for each database object."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"gpadmin=# SELECT * FROM gp_toolkit.gp_bloat_expected_pages LIMIT 5;\n btdrelid | btdrelpages | btdexppages \n----------+-------------+-------------\n    10789 |           1 |           1\n    10794 |           1 |           1\n    10799 |           1 |           1\n     5004 |           1 |           1\n     7175 |           1 |           1\n(5 rows)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"btdrelid"})," is the object ID of the table. The ",(0,n.jsx)(t.code,{children:"btdrelpages"})," column reports the number of pages the table uses; the ",(0,n.jsx)(t.code,{children:"btdexppages"})," column is the number of pages expected. Again, the numbers reported are based on the table statistics, so be sure to run ",(0,n.jsx)(t.code,{children:"ANALYZE"})," on tables that have changed."]}),"\n",(0,n.jsx)(t.h2,{id:"remove-bloat-from-database-tables",children:"Remove bloat from database tables"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"VACUUM"})," command adds expired rows to the free space map so that the space can be reused. When ",(0,n.jsx)(t.code,{children:"VACUUM"})," is run regularly on a table that is frequently updated, the space occupied by the expired rows can be promptly reused, preventing the table file from growing larger. It is also important to run ",(0,n.jsx)(t.code,{children:"VACUUM"})," before the free space map is filled. For heavily updated tables, you may need to run ",(0,n.jsx)(t.code,{children:"VACUUM"})," at least once a day to prevent the table from becoming bloated."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Caution"})," When a table is significantly bloated, it is better to run ",(0,n.jsx)(t.code,{children:"VACUUM"})," before running ",(0,n.jsx)(t.code,{children:"ANALYZE"}),". Analyzing a severely bloated table can generate poor statistics if the sample contains empty pages, so it is good practice to vacuum a bloated table before analyzing it."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["When a table accumulates significant bloat, running the ",(0,n.jsx)(t.code,{children:"VACUUM"})," command is insufficient. For small tables, running ",(0,n.jsx)(t.code,{children:"VACUUM FULL <table_name>"})," can reclaim space used by rows that overflowed the free space map and reduce the size of the table file. However, a ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," statement is an expensive operation that requires an ",(0,n.jsx)(t.code,{children:"ACCESS EXCLUSIVE"})," lock and may take an exceptionally long and unpredictable amount of time to finish for large tables. You should run ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," on tables during a time when users and applications do not require access to the tables being vacuumed, such as during a time of low activity, or during a maintenance window."]}),"\n",(0,n.jsx)(t.h2,{id:"remove-bloat-from-append-optimized-tables",children:"Remove bloat from append-optimized tables"}),"\n",(0,n.jsxs)(t.p,{children:["Append-optimized tables are handled much differently than heap tables. Although append-optimized tables allow update, insert, and delete operations, these operations are not optimized and are not recommended with append-optimized tables. If you heed this advice and use append-optimized for ",(0,n.jsx)(t.em,{children:"load-once/read-many"})," workloads, ",(0,n.jsx)(t.code,{children:"VACUUM"})," on an append-optimized table runs almost instantaneously."]}),"\n",(0,n.jsxs)(t.p,{children:["If you do run ",(0,n.jsx)(t.code,{children:"UPDATE"})," or ",(0,n.jsx)(t.code,{children:"DELETE"})," commands on an append-optimized table, expired rows are tracked in an auxiliary bitmap instead of the free space map. ",(0,n.jsx)(t.code,{children:"VACUUM"})," is the only way to recover the space. Running ",(0,n.jsx)(t.code,{children:"VACUUM"})," on an append-optimized table with expired rows compacts a table by rewriting the entire table without the expired rows. However, no action is performed if the percentage of expired rows in the table exceeds the value of the ",(0,n.jsx)(t.code,{children:"gp_appendonly_compaction_threshold"})," configuration parameter, which is 10 (10%) by default. The threshold is checked on each segment, so it is possible that a ",(0,n.jsx)(t.code,{children:"VACUUM"})," statement will compact an append-only table on some segments and not others. Compacting append-only tables can be deactivated by setting the ",(0,n.jsx)(t.code,{children:"gp_appendonly_compaction"})," parameter to ",(0,n.jsx)(t.code,{children:"no"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"remove-bloat-from-indexes",children:"Remove bloat from indexes"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"VACUUM"})," command only recovers space from tables. To recover the space from indexes, recreate them using the ",(0,n.jsx)(t.code,{children:"REINDEX"})," command."]}),"\n",(0,n.jsxs)(t.p,{children:["To rebuild all indexes on a table run ",(0,n.jsx)(t.code,{children:"REINDEX *table_name*;"}),". To rebuild a particular index, run ",(0,n.jsx)(t.code,{children:"REINDEX *index_name*;"}),". ",(0,n.jsx)(t.code,{children:"REINDEX"})," sets the ",(0,n.jsx)(t.code,{children:"reltuples"})," and ",(0,n.jsx)(t.code,{children:"relpages"})," to 0 (zero) for the index, To update those statistics, run ",(0,n.jsx)(t.code,{children:"ANALYZE"})," on the table after reindexing."]}),"\n",(0,n.jsx)(t.h2,{id:"remove-bloat-from-system-catalogs",children:"Remove bloat from system catalogs"}),"\n",(0,n.jsxs)(t.p,{children:["Apache Cloudberry system catalog tables are heap tables and can become bloated over time. As database objects are created, altered, or dropped, expired rows are left in the system catalogs. Using ",(0,n.jsx)(t.code,{children:"gpload"})," to load data contributes to the bloat because ",(0,n.jsx)(t.code,{children:"gpload"})," creates and drops external tables. (Rather than use ",(0,n.jsx)(t.code,{children:"gpload"}),", it is recommended to use ",(0,n.jsx)(t.code,{children:"gpfdist"})," to load data.)"]}),"\n",(0,n.jsx)(t.p,{children:"Bloat in the system catalogs increases the time require to scan the tables, for example, when creating explain plans. System catalogs are scanned frequently and if they become bloated, overall system performance is degraded."}),"\n",(0,n.jsxs)(t.p,{children:["It is recommended to run ",(0,n.jsx)(t.code,{children:"VACUUM"})," on system catalog tables nightly and at least weekly. At the same time, running ",(0,n.jsx)(t.code,{children:"REINDEX SYSTEM"})," on system catalog tables removes bloat from the indexes. Alternatively, you can reindex system tables using the ",(0,n.jsx)(t.code,{children:"reindexdb"})," utility with the ",(0,n.jsx)(t.code,{children:"-s"})," (",(0,n.jsx)(t.code,{children:"--system"}),") option. After removing catalog bloat, run ",(0,n.jsx)(t.code,{children:"ANALYZE"})," to update catalog table statistics."]}),"\n",(0,n.jsx)(t.p,{children:"These are Apache Cloudberry system catalog maintenance steps."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Perform a ",(0,n.jsx)(t.code,{children:"REINDEX"})," on the system catalog tables to rebuild the system catalog indexes. This removes bloat in the indexes and improves ",(0,n.jsx)(t.code,{children:"VACUUM"})," performance."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Note"})," When performing ",(0,n.jsx)(t.code,{children:"REINDEX"})," on the system catalog tables, locking will occur on the tables and might have an impact on currently running queries. You can schedule the ",(0,n.jsx)(t.code,{children:"REINDEX"})," operation during a period of low activity to avoid disrupting ongoing business operations."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Perform a ",(0,n.jsx)(t.code,{children:"VACUUM"})," on system catalog tables."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Perform an ",(0,n.jsx)(t.code,{children:"ANALYZE"})," on the system catalog tables to update the table statistics."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["If you are performing system catalog maintenance during a maintenance period and you need to stop a process due to time constraints, run the Apache Cloudberry function ",(0,n.jsx)(t.code,{children:"pg_cancel_backend(<PID>)"})," to safely stop a Apache Cloudberry process."]}),"\n",(0,n.jsxs)(t.p,{children:["The following script runs ",(0,n.jsx)(t.code,{children:"REINDEX"}),", ",(0,n.jsx)(t.code,{children:"VACUUM"}),", and ",(0,n.jsx)(t.code,{children:"ANALYZE"})," on the system catalogs."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-shell",children:"#!/bin/bash\nDBNAME=\"<database_name>\"\nSYSTABLES=\"' pg_catalog.' || relname || ';' from pg_class a, pg_namespace b \\\nwhere a.relnamespace=b.oid and b.nspname='pg_catalog' and a.relkind='r'\"\n\nreindexdb -s -d $DBNAME\npsql -tc \"SELECT 'VACUUM' || $SYSTABLES\" $DBNAME | psql -a $DBNAME\nanalyzedb -a -s pg_catalog -d $DBNAME\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If the system catalogs become significantly bloated, you must run ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," during a scheduled downtime period. During this period, stop all catalog activity on the system; ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," takes ",(0,n.jsx)(t.code,{children:"ACCESS EXCLUSIVE"})," locks against the system catalog. Running ",(0,n.jsx)(t.code,{children:"VACUUM"})," regularly on system catalog tables can prevent the need for this more costly procedure."]}),"\n",(0,n.jsx)(t.p,{children:"These are steps for intensive system catalog maintenance."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Stop all catalog activity on the Apache Cloudberry system."}),"\n",(0,n.jsxs)(t.li,{children:["Perform a ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," on the system catalog tables. See the following Note."]}),"\n",(0,n.jsxs)(t.li,{children:["Perform an ",(0,n.jsx)(t.code,{children:"ANALYZE"})," on the system catalog tables to update the catalog table statistics."]}),"\n"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Note"})," The system catalog table ",(0,n.jsx)(t.code,{children:"pg_attribute"})," is usually the largest catalog table. If the ",(0,n.jsx)(t.code,{children:"pg_attribute"})," table is significantly bloated, a ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," operation on the table might require a significant amount of time and might need to be performed separately. The presence of both of these conditions indicate a significantly bloated ",(0,n.jsx)(t.code,{children:"pg_attribute"})," table that might require a long ",(0,n.jsx)(t.code,{children:"VACUUM FULL"})," time:"]}),"\n"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"pg_attribute"})," table contains a large number of records."]}),"\n",(0,n.jsxs)(t.li,{children:["The diagnostic message for ",(0,n.jsx)(t.code,{children:"pg_attribute"})," is ",(0,n.jsx)(t.code,{children:"significant amount of bloat"})," in the ",(0,n.jsx)(t.code,{children:"gp_toolkit.gp_bloat_diag"})," view."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>r,a:()=>i});var n=a(67294);const s={},o=n.createContext(s);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);
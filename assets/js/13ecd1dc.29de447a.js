"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[97760],{54816:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>c,toc:()=>a});var r=s(85893),d=s(11151);const n={title:"Text Search Parsers"},i="Text Search Parsers",c={id:"operate-with-data/sql-queries/full-text-search/text-search-parsers",title:"Text Search Parsers",description:"This document describes the types of tokens the Apache Cloudberry text search parser produces from raw text.",source:"@site/versioned_docs/version-2.x/operate-with-data/sql-queries/full-text-search/text-search-parsers.md",sourceDirName:"operate-with-data/sql-queries/full-text-search",slug:"/operate-with-data/sql-queries/full-text-search/text-search-parsers",permalink:"/docs/operate-with-data/sql-queries/full-text-search/text-search-parsers",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/sql-queries/full-text-search/text-search-parsers.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756779347,formattedLastUpdatedAt:"Sep 2, 2025",frontMatter:{title:"Text Search Parsers"},sidebar:"docsbars",previous:{title:"Additional Text Search Features",permalink:"/docs/operate-with-data/sql-queries/full-text-search/additional-text-search-features"},next:{title:"Text Search Dictionaries",permalink:"/docs/operate-with-data/sql-queries/full-text-search/text-search-dictionaries"}},l={},a=[];function o(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"text-search-parsers",children:"Text Search Parsers"}),"\n",(0,r.jsx)(t.p,{children:"This document describes the types of tokens the Apache Cloudberry text search parser produces from raw text."}),"\n",(0,r.jsxs)(t.p,{children:["Text search parsers are responsible for splitting raw document text into ",(0,r.jsx)(t.em,{children:"tokens"})," and identifying each token's type, where the set of possible types is defined by the parser itself. Note that a parser does not modify the text at all \u2014 it simply identifies plausible word boundaries. Because of this limited scope, there is less need for application-specific custom parsers than there is for custom dictionaries. At present Apache Cloudberry provides just one built-in parser, which has been found to be useful for a wide range of applications."]}),"\n",(0,r.jsxs)(t.p,{children:["The built-in parser is named ",(0,r.jsx)(t.code,{children:"pg_catalog.default"}),". It recognizes 23 token types, shown in the following table."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Alias"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Example"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"asciiword"}),(0,r.jsx)(t.td,{children:"Word, all ASCII letters"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"elephant"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"word"}),(0,r.jsx)(t.td,{children:"Word, all letters"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"ma\xf1ana"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"numword"}),(0,r.jsx)(t.td,{children:"Word, letters and digits"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"beta1"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"asciihword"}),(0,r.jsx)(t.td,{children:"Hyphenated word, all ASCII"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"up-to-date"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hword"}),(0,r.jsx)(t.td,{children:"Hyphenated word, all letters"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"l\xf3gico-matem\xe1tica"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"numhword"}),(0,r.jsx)(t.td,{children:"Hyphenated word, letters and digits"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"postgresql-beta1"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hword_asciipart"}),(0,r.jsx)(t.td,{children:"Hyphenated word part, all ASCII"}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"postgresql"})," in the context ",(0,r.jsx)(t.code,{children:"postgresql-beta1"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hword_part"}),(0,r.jsx)(t.td,{children:"Hyphenated word part, all letters"}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"l\xf3gico"})," or ",(0,r.jsx)(t.code,{children:"matem\xe1tica"})," in the context ",(0,r.jsx)(t.code,{children:"l\xf3gico-matem\xe1tica"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hword_numpart"}),(0,r.jsx)(t.td,{children:"Hyphenated word part, letters and digits"}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"beta1"})," in the context ",(0,r.jsx)(t.code,{children:"postgresql-beta1"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"email"}),(0,r.jsx)(t.td,{children:"Email address"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"foo@example.com"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"protocol"}),(0,r.jsx)(t.td,{children:"Protocol head"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"http://"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"url"}),(0,r.jsx)(t.td,{children:"URL"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"example.com/stuff/index.html"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"host"}),(0,r.jsx)(t.td,{children:"Host"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"example.com"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"url_path"}),(0,r.jsx)(t.td,{children:"URL path"}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"/stuff/index.html"}),", in the context of a URL"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"file"}),(0,r.jsx)(t.td,{children:"File or path name"}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"/usr/local/foo.txt"}),", if not within a URL"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"sfloat"}),(0,r.jsx)(t.td,{children:"Scientific notation"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"-1.234e56"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"float"}),(0,r.jsx)(t.td,{children:"Decimal notation"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"-1.234"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"int"}),(0,r.jsx)(t.td,{children:"Signed integer"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"-1234"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"uint"}),(0,r.jsx)(t.td,{children:"Unsigned integer"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"1234"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"version"}),(0,r.jsx)(t.td,{children:"Version number"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"8.3.0"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"tag"}),(0,r.jsx)(t.td,{children:"XML tag"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:'<a href="dictionaries.html">'})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"entity"}),(0,r.jsx)(t.td,{children:"XML entity"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"&amp;"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"blank"}),(0,r.jsx)(t.td,{children:"Space symbols"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"(any whitespace or punctuation not otherwise recognized)"})})]})]})]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["The parser's notion of a \"letter\" is determined by the database's locale setting, specifically ",(0,r.jsx)(t.code,{children:"lc_ctype"}),". Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types ",(0,r.jsx)(t.code,{children:"word"})," and ",(0,r.jsx)(t.code,{children:"asciiword"})," should be treated alike."]})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"email"})," does not support all valid email characters as defined by RFC 5322. Specifically, the only non-alphanumeric characters supported for email user names are period, dash, and underscore."]}),"\n",(0,r.jsx)(t.p,{children:"It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"SELECT alias, description, token FROM ts_debug('foo-bar-beta1');\n      alias      |               description                |     token     \n-----------------+------------------------------------------+---------------\n numhword        | Hyphenated word, letters and digits      | foo-bar-beta1\n hword_asciipart | Hyphenated word part, all ASCII          | foo\n blank           | Space symbols                            | -\n hword_asciipart | Hyphenated word part, all ASCII          | bar\n blank           | Space symbols                            | -\n hword_numpart   | Hyphenated word part, letters and digits | beta1\n"})}),"\n",(0,r.jsx)(t.p,{children:"This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"SELECT alias, description, token FROM ts_debug('http://example.com/stuff/index.html');\n  alias   |  description  |            token             \n----------+---------------+------------------------------\n protocol | Protocol head | http://\n url      | URL           | example.com/stuff/index.html\n host     | Host          | example.com\n url_path | URL path      | /stuff/index.html\n"})})]})}function h(e={}){const{wrapper:t}={...(0,d.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>c,a:()=>i});var r=s(67294);const d={},n=r.createContext(d);function i(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);
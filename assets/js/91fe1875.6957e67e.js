"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[57881],{98954:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>n,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=t(85893),s=t(11151);const a={title:"High Availability"},n="High Availability",o={id:"tutorials/best-practices/high-availability-best-practices",title:"High Availability",description:"Apache Cloudberry supports highly available, fault-tolerant database services when you enable and properly configure Cloudberry high availability features. To guarantee a required level of service, each component must have a standby ready to take its place if it should fail.",source:"@site/versioned_docs/version-2.x/tutorials/best-practices/high-availability-best-practices.md",sourceDirName:"tutorials/best-practices",slug:"/tutorials/best-practices/high-availability-best-practices",permalink:"/docs/tutorials/best-practices/high-availability-best-practices",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/tutorials/best-practices/high-availability-best-practices.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1758076255,formattedLastUpdatedAt:"Sep 17, 2025",frontMatter:{title:"High Availability"},sidebar:"docsbars",previous:{title:"Encrypt Data and Database Connections",permalink:"/docs/tutorials/best-practices/db-encryption-best-practices"},next:{title:"Memory and Resource Management with Resource Groups",permalink:"/docs/tutorials/best-practices/resource-group-best-practices"}},c={},l=[{value:"Disk storage",id:"disk-storage",level:2},{value:"Best practices",id:"best-practices",level:3},{value:"Coordinator mirroring",id:"coordinator-mirroring",level:2},{value:"Best practices",id:"best-practices-1",level:3},{value:"Segment mirroring",id:"segment-mirroring",level:2},{value:"Best practices",id:"best-practices-2",level:3},{value:"Dual clusters",id:"dual-clusters",level:2},{value:"Best practices",id:"best-practices-3",level:3},{value:"Backup and restore",id:"backup-and-restore",level:2},{value:"Best practices",id:"best-practices-4",level:3},{value:"Detect failed coordinator and segment instances",id:"detect-failed-coordinator-and-segment-instances",level:2},{value:"Best practices",id:"best-practices-5",level:3},{value:"Additional information",id:"additional-information",level:3},{value:"Configure segment mirroring",id:"configure-segment-mirroring",level:2},{value:"Configure group mirroring",id:"configure-group-mirroring",level:3},{value:"Configure spread mirroring",id:"configure-spread-mirroring",level:3},{value:"Configure block mirroring",id:"configure-block-mirroring",level:3},{value:"Implement block mirroring",id:"implement-block-mirroring",level:3}];function d(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h1,{id:"high-availability",children:"High Availability"}),"\n",(0,i.jsx)(r.p,{children:"Apache Cloudberry supports highly available, fault-tolerant database services when you enable and properly configure Cloudberry high availability features. To guarantee a required level of service, each component must have a standby ready to take its place if it should fail."}),"\n",(0,i.jsx)(r.h2,{id:"disk-storage",children:"Disk storage"}),"\n",(0,i.jsx)(r.p,{children:'With the Apache Cloudberry "shared-nothing" MPP architecture, the coordinator host and segment hosts each have their own dedicated memory and disk storage, and each coordinator or segment instance has its own independent data directory. For both reliability and high performance, it is recommended to use a hardware RAID storage solution with from 8 to 24 disks. A larger number of disks improves I/O throughput when using RAID 5 (or 6) because striping increases parallel disk I/O. The RAID controller can continue to function with a failed disk because it saves parity data on each disk in a way that it can reconstruct the data on any failed member of the array. If a hot spare is configured (or an operator replaces the failed disk with a new one) the controller rebuilds the failed disk automatically.'}),"\n",(0,i.jsx)(r.p,{children:"RAID 1 exactly mirrors disks, so if a disk fails, a replacement is immediately available with performance equivalent to that before the failure. With RAID 5 each I/O for data on the failed array member must be reconstructed from data on the remaining active drives until the replacement disk is rebuilt, so there is a temporary performance degradation. If the Cloudberry coordinator and segments are mirrored, you can switch any affected Cloudberry instances to their mirrors during the rebuild to maintain acceptable performance."}),"\n",(0,i.jsx)(r.p,{children:"A RAID disk array can still be a single point of failure, for example, if the entire RAID volume fails. At the hardware level, you can protect against a disk array failure by mirroring the array, using either host operating system mirroring or RAID controller mirroring, if supported."}),"\n",(0,i.jsxs)(r.p,{children:["It is important to regularly monitor available disk space on each segment host. Query the ",(0,i.jsx)(r.code,{children:"gp_disk_free"})," external table in the ",(0,i.jsx)(r.code,{children:"gptoolkit"})," schema to view disk space available on the segments. This view runs the Linux ",(0,i.jsx)(r.code,{children:"df"})," command. Be sure to check that there is sufficient disk space before performing operations that consume large amounts of disk, such as copying a large table."]}),"\n",(0,i.jsx)(r.h3,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Use a hardware RAID storage solution with 8 to 24 disks."}),"\n",(0,i.jsx)(r.li,{children:"Use RAID 1, 5, or 6 so that the disk array can tolerate a failed disk."}),"\n",(0,i.jsx)(r.li,{children:"Configure a hot spare in the disk array to allow rebuild to begin automatically when disk failure is detected."}),"\n",(0,i.jsx)(r.li,{children:"Protect against failure of the entire disk array and degradation during rebuilds by mirroring the RAID volume."}),"\n",(0,i.jsx)(r.li,{children:"Monitor disk utilization regularly and add additional space when needed."}),"\n",(0,i.jsx)(r.li,{children:"Monitor segment skew to ensure that data is distributed evenly and storage is consumed evenly at all segments."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"coordinator-mirroring",children:"Coordinator mirroring"}),"\n",(0,i.jsx)(r.p,{children:"The Apache Cloudberry coordinator instance is clients' single point of access to the system. The coordinator instance stores the global system catalog, the set of system tables that store metadata about the database instance, but no user data. If an unmirrored coordinator instance fails or becomes inaccessible, the Cloudberry instance is effectively off-line, because the entry point to the system has been lost. For this reason, a standby coordinator must be ready to take over if the primary coordinator fails."}),"\n",(0,i.jsx)(r.p,{children:"Coordinator mirroring uses two processes, a sender on the active coordinator host and a receiver on the mirror host, to synchronize the mirror with the coordinator. As changes are applied to the coordinator system catalogs, the active coordinator streams its write-ahead log (WAL) to the mirror so that each transaction applied on the coordinator is applied on the mirror."}),"\n",(0,i.jsxs)(r.p,{children:["The mirror is a ",(0,i.jsx)(r.em,{children:"warm standby"}),". If the primary coordinator fails, switching to the standby requires an administrative user to run the ",(0,i.jsx)(r.code,{children:"gpactivatestandby"})," utility on the standby host so that it begins to accept client connections. Clients must reconnect to the new coordinator and will lose any work that was not committed when the primary failed."]}),"\n",(0,i.jsx)(r.h3,{id:"best-practices-1",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Set up a standby coordinator instance\u2014a ",(0,i.jsx)(r.em,{children:"mirror"}),"\u2014to take over if the primary coordinator fails."]}),"\n",(0,i.jsx)(r.li,{children:"The standby can be on the same host or on a different host, but it is best practice to place it on a different host from the primary coordinator to protect against host failure."}),"\n",(0,i.jsx)(r.li,{children:"Plan how to switch clients to the new coordinator instance when a failure occurs, for example, by updating the coordinator address in DNS."}),"\n",(0,i.jsx)(r.li,{children:"Set up monitoring to send notifications in a system monitoring application or by email when the primary fails."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"segment-mirroring",children:"Segment mirroring"}),"\n",(0,i.jsx)(r.p,{children:"Apache Cloudberry segment instances each store and manage a portion of the database data, with coordination from the coordinator instance. If any unmirrored segment fails, the database may have to be shutdown and recovered, and transactions occurring after the most recent backup could be lost. Mirroring segments is, therefore, an essential element of a high availability solution."}),"\n",(0,i.jsx)(r.p,{children:"A segment mirror is a hot standby for a primary segment. Apache Cloudberry detects when a segment is unavailable and automatically activates the mirror. During normal operation, when the primary segment instance is active, data is replicated from the primary to the mirror in two ways:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"The transaction commit log is replicated from the primary to the mirror before the transaction is committed. This ensures that if the mirror is activated, the changes made by the last successful transaction at the primary are present at the mirror. When the mirror is activated, transactions in the log are applied to tables in the mirror."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Second, segment mirroring uses physical file replication to update heap tables. Cloudberry Server stores table data on disk as fixed-size blocks packed with tuples. To optimize disk I/O, blocks are cached in memory until the cache fills and some blocks must be evicted to make room for newly updated blocks. When a block is evicted from the cache it is written to disk and replicated over the network to the mirror. Because of the caching mechanism, table updates at the mirror can lag behind the primary. However, because the transaction log is also replicated, the mirror remains consistent with the primary. If the mirror is activated, the activation process updates the tables with any unapplied changes in the transaction commit log."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:'When the acting primary is unable to access its mirror, replication stops and state of the primary changes to "Change Tracking." The primary saves changes that have not been replicated to the mirror in a system table to be replicated to the mirror when it is back on-line.'}),"\n",(0,i.jsx)(r.p,{children:"The coordinator automatically detects segment failures and activates the mirror. Transactions in progress at the time of failure are restarted using the new primary. Depending on how mirrors are deployed on the hosts, the database system may be unbalanced until the original primary segment is recovered. For example, if each segment host has four primary segments and four mirror segments, and a mirror is activated on one host, that host will have five active primary segments. Queries are not complete until the last segment has finished its work, so performance can be degraded until the balance is restored by recovering the original primary."}),"\n",(0,i.jsxs)(r.p,{children:["Administrators perform the recovery while Apache Cloudberry is up and running by running the ",(0,i.jsx)(r.code,{children:"gprecoverseg"})," utility. This utility locates the failed segments, verifies they are valid, and compares the transactional state with the currently active segment to determine changes made while the segment was offline. ",(0,i.jsx)(r.code,{children:"gprecoverseg"})," synchronizes the changed database files with the active segment and brings the segment back online."]}),"\n",(0,i.jsx)(r.p,{children:"It is important to reserve enough memory and CPU resources on segment hosts to allow for increased activity from mirrors that assume the primary role during a failure."}),"\n",(0,i.jsx)(r.h3,{id:"best-practices-2",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Set up mirrors for all segments."}),"\n",(0,i.jsx)(r.li,{children:"Locate primary segments and their mirrors on different hosts to protect against host failure."}),"\n",(0,i.jsx)(r.li,{children:"Mirrors can be on a separate set of hosts or co-located on hosts with primary segments."}),"\n",(0,i.jsx)(r.li,{children:"Set up monitoring to send notifications in a system monitoring application or by email when a primary segment fails."}),"\n",(0,i.jsxs)(r.li,{children:["Recover failed segments promptly, using the ",(0,i.jsx)(r.code,{children:"gprecoverseg"})," utility, to restore redundancy and return the system to optimal balance."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"dual-clusters",children:"Dual clusters"}),"\n",(0,i.jsx)(r.p,{children:"For some use cases, an additional level of redundancy can be provided by maintaining two Apache Cloudberry clusters that store the same data. The decision to implement dual clusters should be made with business requirements in mind."}),"\n",(0,i.jsx)(r.p,{children:"There are two recommended methods for keeping the data synchronized in a dual cluster configuration. The first method is called Dual ETL. ETL (extract, transform, and load) is the common data warehousing process of cleansing, transforming, validating, and loading data into a data warehouse. With Dual ETL, the ETL processes are performed twice, in parallel on each cluster, and validated each time. Dual ETL provides for a complete standby cluster with the same data. It also provides the capability to query the data on both clusters, doubling the processing throughput. The application can take advantage of both clusters as needed and also ensure that the ETL is successful and validated on both sides."}),"\n",(0,i.jsx)(r.p,{children:"The second mechanism for maintaining dual clusters is backup and restore. The data is backed\xadup on the primary cluster, then the backup is replicated to and restored on the second cluster. The backup and restore mechanism has higher latency than Dual ETL, but requires less application logic to be developed. Backup and restore is ideal for use cases where data modifications and ETL are done daily or less frequently."}),"\n",(0,i.jsx)(r.h3,{id:"best-practices-3",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Consider a Dual Cluster configuration to provide an additional level of redundancy and additional query processing throughput."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"backup-and-restore",children:"Backup and restore"}),"\n",(0,i.jsx)(r.p,{children:"Backups are recommended for Apache Cloudberry databases unless the data in the database can be easily and cleanly regenerated from source data. Backups protect from operational, software, or hardware errors."}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"gpbackup"})," utility makes backups in parallel across the segments, so that backups scale as the cluster grows in hardware size."]}),"\n",(0,i.jsx)(r.p,{children:"A backup strategy must consider where the backups will be written and where they will be stored. Backups can be taken to the local cluster disks, but they should not be stored there permanently. If the database and its backup are on the same storage, they can be lost simultaneously. The backup also occupies space that could be used for database storage or operations. After performing a local backup, the files should be copied to a safe, off-cluster location."}),"\n",(0,i.jsx)(r.p,{children:"An alternative is to back up directly to an NFS mount. If each host in the cluster has an NFS mount, the backups can be written directly to NFS storage. A scale-out NFS solution is recommended to ensure that backups do not bottleneck on the IO throughput of the NFS device. Dell EMC Isilon is an example of this type of solution and can scale alongside the Cloudberry cluster."}),"\n",(0,i.jsx)(r.p,{children:"Finally, through native API integration, Apache Cloudberry can stream backups directly to the Dell EMC Data Domain enterprise backup platform."}),"\n",(0,i.jsx)(r.h3,{id:"best-practices-4",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Back up Apache Cloudberrys regularly unless the data is easily restored from sources."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["Use the ",(0,i.jsx)(r.code,{children:"gpbackup"})," command to specify only the schema and tables that you want backed up. See the ",(0,i.jsx)(r.a,{href:"/docs/sys-admin/backup-and-restore/",children:(0,i.jsx)(r.code,{children:"gpbackup"})})," reference for more information."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"gpbackup"})," places ",(0,i.jsx)(r.code,{children:"SHARED ACCESS"})," locks on the set of tables to back up. Backups with fewer tables are more efficient for selectively restoring schemas and tables, because ",(0,i.jsx)(r.code,{children:"gprestore"})," does not have to search through the entire database."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"If backups are saved to local cluster storage, move the files to a safe, off-cluster location when the backup is complete. Backup files and database files that reside on the same storage can be lost simultaneously."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"If backups are saved to NFS mounts, use a scale-out NFS solution such as Dell EMC Isilon to prevent IO bottlenecks."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Cloudberry users should consider streaming backups to the Dell EMC Data Domain enterprise backup platform."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"detect-failed-coordinator-and-segment-instances",children:"Detect failed coordinator and segment instances"}),"\n",(0,i.jsx)(r.p,{children:"Recovering from system failures requires intervention from a system administrator, even when the system detects a failure and activates a standby for the failed component. In each case, the failed component must be replaced or recovered to restore full redundancy. Until the failed component is recovered, the active component lacks a standby, and the system may not be performing optimally. For these reasons, it is important to perform recovery operations promptly. Constant system monitoring ensures that administrators are aware of failures that demand their attention."}),"\n",(0,i.jsxs)(r.p,{children:["The Apache Cloudberry server ",(0,i.jsx)(r.code,{children:"ftsprobe"})," subprocess handles fault detection. ",(0,i.jsx)(r.code,{children:"ftsprobe"})," connects to and scans all segments and database processes at intervals that you can configure with the ",(0,i.jsx)(r.code,{children:"gp_fts_probe_interval"})," configuration parameter. If ",(0,i.jsx)(r.code,{children:"ftsprobe"})," cannot connect to a segment, it marks the segment \u201cdown\u201d in the Apache Cloudberry system catalog. The segment remains down until an administrator runs the ",(0,i.jsx)(r.code,{children:"gprecoverseg"})," recovery utility."]}),"\n",(0,i.jsx)(r.h3,{id:"best-practices-5",children:"Best practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Run the ",(0,i.jsx)(r.code,{children:"gpstate"})," utility to see the overall state of the Cloudberry system."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"additional-information",children:"Additional information"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"Apache Cloudberry Administrator Guide"}),":"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"/docs/sys-admin/check-database-system",children:"Monitor a Cloudberry System"})}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"Apache Cloudberry Utility Guide"}),":"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/sys-utilities/gpstate",children:"gpstate"})," - view state of the Cloudberry system"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/sys-utilities/gprecoverseg",children:"gprecoverseg"})," - recover a failed segment"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"/docs/sys-utilities/gpactivatestandby",children:"gpactivatestandby"})," - make the standby coordinator the active coordinator"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://datatracker.ietf.org/doc/html/rfc1697",children:"RDBMS MIB Specification"})}),"\n",(0,i.jsx)(r.h2,{id:"configure-segment-mirroring",children:"Configure segment mirroring"}),"\n",(0,i.jsx)(r.p,{children:"Segment mirroring allows database queries to fail over to a backup segment if the primary segment fails or becomes unavailable. Cloudberry requires mirroring for supported production Apache Cloudberry systems."}),"\n",(0,i.jsx)(r.p,{children:"A primary segment and its mirror must be on different hosts to ensure high availability. Each host in a Apache Cloudberry system has the same number of primary segments and mirror segments. Multi-homed hosts should have the same numbers of primary and mirror segments on each interface. This ensures that segment hosts and network resources are equally loaded when all primary segments are operational and brings the most resources to bear on query processing."}),"\n",(0,i.jsx)(r.p,{children:"When a segment becomes unavailable, its mirror segment on another host becomes the active primary and processing continues. The additional load on the host creates skew and degrades performance, but should allow the system to continue. A database query is not complete until all segments return results, so a single host with an additional active primary segment has the same effect as adding an additional primary segment to every host in the cluster."}),"\n",(0,i.jsx)(r.p,{children:"The least amount of performance degradation in a failover scenario occurs when no host has more than one mirror assuming the primary role. If multiple segments or hosts fail, the amount of degradation is determined by the host or hosts with the largest number of mirrors assuming the primary role. Spreading a host's mirrors across the remaining hosts minimizes degradation when any single host fails."}),"\n",(0,i.jsx)(r.p,{children:"It is important, too, to consider the cluster's tolerance for multiple host failures and how to maintain a mirror configuration when expanding the cluster by adding hosts. There is no mirror configuration that is ideal for every situation."}),"\n",(0,i.jsx)(r.p,{children:"You can allow Apache Cloudberry to arrange mirrors on the hosts in the cluster using one of two standard configurations, or you can design your own mirroring configuration."}),"\n",(0,i.jsxs)(r.p,{children:["The two standard mirroring arrangements are ",(0,i.jsx)(r.em,{children:"group mirroring"})," and ",(0,i.jsx)(r.em,{children:"spread mirroring"}),":"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Group mirroring"})," \u2014 Each host mirrors another host's primary segments. This is the default for ",(0,i.jsx)(r.code,{children:"gpinitsystem"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Spread mirroring"})," \u2014 Mirrors are spread across the available hosts. This requires that the number of hosts in the cluster is greater than the number of segments per host."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["You can design a custom mirroring configuration and use the Cloudberry ",(0,i.jsx)(r.code,{children:"gpaddmirrors"})," or ",(0,i.jsx)(r.a,{href:"/docs/sys-utilities/gpmovemirrors",children:(0,i.jsx)(r.code,{children:"gpmovemirrors"})})," utilities to set up the configuration."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"Block mirroring"})," is a custom mirror configuration that divides hosts in the cluster into equally sized blocks and distributes mirrors evenly to hosts within the block. If a primary segment fails, its mirror on another host within the same block becomes the active primary. If a segment host fails, mirror segments on each of the other hosts in the block become active."]}),"\n",(0,i.jsx)(r.p,{children:"The following sections compare the group, spread, and block mirroring configurations."}),"\n",(0,i.jsx)(r.h3,{id:"configure-group-mirroring",children:"Configure group mirroring"}),"\n",(0,i.jsx)(r.p,{children:"Group mirroring is easiest to set up and is the default Cloudberry mirroring configuration. It is least expensive to expand, because it can be done by adding as few as two hosts. There is no need to move mirrors after expansion to maintain a consistent mirror configuration."}),"\n",(0,i.jsx)(r.p,{children:"The following diagram shows a group mirroring configuration with eight primary segments on four hosts."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"Group mirroring configuration",src:t(77968).Z+"",width:"464",height:"432"})}),"\n",(0,i.jsx)(r.p,{children:"Unless both the primary and mirror of the same segment instance fail, up to half of your hosts can fail and the cluster will continue to run as long as resources (CPU, memory, and IO) are sufficient to meet the needs."}),"\n",(0,i.jsx)(r.p,{children:"Any host failure will degrade performance by half or more because the host with the mirrors will have twice the number of active primaries. If your resource utilization is normally greater than 50%, you will have to adjust your workload until the failed host is recovered or replaced. If you normally run at less than 50% resource utilization the cluster can continue to operate at a degraded level of performance until the failure is corrected."}),"\n",(0,i.jsx)(r.h3,{id:"configure-spread-mirroring",children:"Configure spread mirroring"}),"\n",(0,i.jsx)(r.p,{children:"With spread mirroring, mirrors for each host's primary segments are spread across as many hosts as there are segments per host. Spread mirroring is easy to set up when the cluster is initialized, but requires that the cluster have at least one more host than there are segments per host."}),"\n",(0,i.jsx)(r.p,{children:"The following diagram shows the spread mirroring configuration for a cluster with three primaries on four hosts."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"Spread mirroring configuration",src:t(38708).Z+"",width:"445",height:"295"})}),"\n",(0,i.jsx)(r.p,{children:"Expanding a cluster with spread mirroring requires more planning and may take more time. You must either add a set of hosts equal to the number of primaries per host plus one, or you can add two nodes in a group mirroring configuration and, when the expansion is complete, move mirrors to recreate the spread mirror configuration."}),"\n",(0,i.jsxs)(r.p,{children:["Spread mirroring has the least performance impact for a single failed host because each host's mirrors are spread across the maximum number of hosts. Load is increased by 1/",(0,i.jsx)(r.em,{children:"Nth"}),", where ",(0,i.jsx)(r.em,{children:"N"})," is the number of primaries per host. Spread mirroring is, however, the most likely configuration to have a catastrophic failure if two or more hosts fail simultaneously."]}),"\n",(0,i.jsx)(r.h3,{id:"configure-block-mirroring",children:"Configure block mirroring"}),"\n",(0,i.jsx)(r.p,{children:"With block mirroring, nodes are divided into blocks, for example a block of four or eight hosts, and the mirrors for segments on each host are placed on other hosts within the block. Depending on the number of hosts in the block and the number of primary segments per host, each host maintains more than one mirror for each other host's segments."}),"\n",(0,i.jsx)(r.p,{children:"The following diagram shows a single block mirroring configuration for a block of four hosts, each with eight primary segments:"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{alt:"Block mirroring configuration",src:t(60758).Z+"",width:"464",height:"432"})}),"\n",(0,i.jsx)(r.p,{children:"If there are eight hosts, an additional four-host block is added with the mirrors for primary segments 32 through 63 set up in the same pattern."}),"\n",(0,i.jsx)(r.p,{children:"A cluster with block mirroring is easy to expand because each block is a self-contained primary mirror group. The cluster is expanded by adding one or more blocks. There is no need to move mirrors after expansion to maintain a consistent mirror setup. This configuration is able to survive multiple host failures as long as the failed hosts are in different blocks."}),"\n",(0,i.jsx)(r.p,{children:"Because each host in a block has multiple mirror instances for each other host in the block, block mirroring has a higher performance impact for host failures than spread mirroring, but a lower impact than group mirroring. The expected performance impact varies by block size and primary segments per node. As with group mirroring, if the resources are available, performance will be negatively impacted but the cluster will remain available. If resources are insufficient to accommodate the added load you must reduce the workload until the failed node is replaced."}),"\n",(0,i.jsx)(r.h3,{id:"implement-block-mirroring",children:"Implement block mirroring"}),"\n",(0,i.jsx)(r.p,{children:"Block mirroring is not one of the automatic options Apache Cloudberry offers when you set up or expand a cluster. To use it, you must create your own configuration."}),"\n",(0,i.jsxs)(r.p,{children:["For a new Cloudberry system, you can initialize the cluster without mirrors, and then run ",(0,i.jsx)(r.code,{children:"gpaddmirrors -i mirror_config_file"})," with a custom mirror configuration file to create the mirrors for each block. You must create the file system locations for the mirror segments before you run ",(0,i.jsx)(r.code,{children:"gpaddmirrors"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["If you expand a system that has block mirroring or you want to implement block mirroring at the same time you expand a cluster, it is recommended that you complete the expansion first, using the default grouping mirror configuration, and then use the ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," utility to move mirrors into the block configuration."]}),"\n",(0,i.jsx)(r.p,{children:"To implement block mirroring with an existing system that has a different mirroring scheme, you must first determine the desired location for each mirror according to your block configuration, and then determine which of the existing mirrors must be relocated. Follow these steps:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Run the following query to find the current locations of the primary and mirror segments:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-sql",children:"SELECT dbid, content, role, port, hostname, datadir FROM gp_segment_configuration WHERE content > -1 ;\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"gp_segment_configuration"})," system catalog table contains the current segment configuration."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Create a list with the current mirror location and the desired block mirroring location, then remove any mirrors from the list that are already on the correct host."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["Create an input file for the ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," utility with an entry for each mirror that must be moved."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," input file has the following format:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-text",children:"old_address|port|data_dir new_address|port|data_dir\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Where ",(0,i.jsx)(r.code,{children:"old_address"})," is the host name or IP address of the segment host, port is the communication port, and ",(0,i.jsx)(r.code,{children:"data_dir"})," is the segment instance data directory."]}),"\n",(0,i.jsxs)(r.p,{children:["The following example ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," input file specifies three mirror segments to move."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-text",children:"sdw2|50001|/data2/mirror/gpseg1 sdw3|50001|/data/mirror/gpseg1\nsdw2|50001|/data2/mirror/gpseg2 sdw4|50001|/data/mirror/gpseg2\nsdw3|50001|/data2/mirror/gpseg3 sdw1|50001|/data/mirror/gpseg3\n"})}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:["Run ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," with a command like the following:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-shell",children:"gpmovemirrors -i mirror_config_file\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," utility validates the input file, calls ",(0,i.jsx)(r.code,{children:"gprecoverseg"})," to relocate each specified mirror, and removes the original mirror. It creates a backout configuration file which can be used as input to ",(0,i.jsx)(r.code,{children:"gpmovemirrors"})," to undo the changes that were made. The backout file has the same name as the input file, with the suffix ",(0,i.jsx)(r.code,{children:"_backout_timestamp"})," added."]})]})}function h(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},60758:(e,r,t)=>{t.d(r,{Z:()=>i});const i=t.p+"assets/images/block-mirror-config-08ef5f185dc04edcb383198122d77f50.png"},77968:(e,r,t)=>{t.d(r,{Z:()=>i});const i=t.p+"assets/images/group-mirroring-1-9b0f633d6000f2ac466c7c8948081629.png"},38708:(e,r,t)=>{t.d(r,{Z:()=>i});const i=t.p+"assets/images/spread-mirror-config-8fcb58deccfd5ced8244d031f11ed9d3.png"},11151:(e,r,t)=>{t.d(r,{Z:()=>o,a:()=>n});var i=t(67294);const s={},a=i.createContext(s);function n(e){const r=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);
"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[99596],{50552:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var t=n(85893),a=n(11151);const r={title:"Group By and Having Clauses"},o="Group By and Having Clauses",i={id:"operate-with-data/sql-queries/group-by-and-having-clauses",title:"Group By and Having Clauses",description:"After passing the WHERE filter, the derived input table might be subject to grouping, using the GROUP BY clause, and elimination of group rows using the HAVING clause.",source:"@site/docs/operate-with-data/sql-queries/group-by-and-having-clauses.md",sourceDirName:"operate-with-data/sql-queries",slug:"/operate-with-data/sql-queries/group-by-and-having-clauses",permalink:"/docs/next/operate-with-data/sql-queries/group-by-and-having-clauses",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/operate-with-data/sql-queries/group-by-and-having-clauses.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1758251426,formattedLastUpdatedAt:"Sep 19, 2025",frontMatter:{title:"Group By and Having Clauses"},sidebar:"docsbars",previous:{title:"WHERE Clauses",permalink:"/docs/next/operate-with-data/sql-queries/where-clauses"},next:{title:"Join Queries",permalink:"/docs/next/operate-with-data/sql-queries/join-queries"}},c={},l=[];function u(e){const s={admonition:"admonition",code:"code",h1:"h1",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"group-by-and-having-clauses",children:"Group By and Having Clauses"}),"\n",(0,t.jsxs)(s.p,{children:["After passing the ",(0,t.jsx)(s.code,{children:"WHERE"})," filter, the derived input table might be subject to grouping, using the ",(0,t.jsx)(s.code,{children:"GROUP BY"})," clause, and elimination of group rows using the ",(0,t.jsx)(s.code,{children:"HAVING"})," clause."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT select_list\n    FROM ...\n    [WHERE ...]\n    GROUP BY grouping_column_reference [, grouping_column_reference]...\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"GROUP BY"})," clause is used to group together those rows in a table that have the same values in all the columns listed. The order in which the columns are listed does not matter. The effect is to combine each set of rows having common values into one group row that represents all rows in the group. This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups. For instance:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"=> SELECT * FROM test1;\n x | y\n---+---\n a | 3\n c | 2\n b | 5\n a | 1\n(4 rows)\n\n=> SELECT x FROM test1 GROUP BY x;\n x\n---\n a\n b\n c\n(3 rows)\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the second query, we could not have written ",(0,t.jsx)(s.code,{children:"SELECT * FROM test1 GROUP BY x"}),", because there is no single value for the column y that could be associated with each group. The grouped-by columns can be referenced in the select list because they have a single value in each group."]}),"\n",(0,t.jsxs)(s.p,{children:["In general, if a table is grouped, columns that are not listed in ",(0,t.jsx)(s.code,{children:"GROUP BY"})," cannot be referenced except in aggregate expressions. An example with aggregate expressions is:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"=> SELECT x, sum(y) FROM test1 GROUP BY x;\n x | sum\n---+-----\n a |   4\n b |   5\n c |   2\n(3 rows)\n"})}),"\n",(0,t.jsx)(s.p,{children:"Here sum is an aggregate function that computes a single value over the entire group."}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the ",(0,t.jsx)(s.code,{children:"DISTINCT"})," clause."]})}),"\n",(0,t.jsx)(s.p,{children:"Here is another example: it calculates the total sales for each product (rather than the total sales of all products):"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT product_id, p.name, (sum(s.units) * p.price) AS sales\n    FROM products p LEFT JOIN sales s USING (product_id)\n    GROUP BY product_id, p.name, p.price;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In this example, the columns ",(0,t.jsx)(s.code,{children:"product_id"}),", ",(0,t.jsx)(s.code,{children:"p.name"}),", and ",(0,t.jsx)(s.code,{children:"p.price"})," must be in the ",(0,t.jsx)(s.code,{children:"GROUP BY"})," clause because they are referenced in the query select list (but see below). The column ",(0,t.jsx)(s.code,{children:"s.units"})," does not have to be in the ",(0,t.jsx)(s.code,{children:"GROUP BY"})," list because it is only used in an aggregate expression (",(0,t.jsx)(s.code,{children:"sum(...)"}),"), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product."]}),"\n",(0,t.jsxs)(s.p,{children:["If the products table is set up so that, say, ",(0,t.jsx)(s.code,{children:"product_id"})," is the primary key, then it would be enough to group by ",(0,t.jsx)(s.code,{children:"product_id"})," in the above example, because name and price would be functionally dependent on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group."]}),"\n",(0,t.jsxs)(s.p,{children:["In strict SQL, ",(0,t.jsx)(s.code,{children:"GROUP BY"})," can only group by columns of the source table but Apache Cloudberry extends this to also allow ",(0,t.jsx)(s.code,{children:"GROUP BY"})," to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed."]}),"\n",(0,t.jsxs)(s.p,{children:["If a table has been grouped using ",(0,t.jsx)(s.code,{children:"GROUP BY"}),", but only certain groups are of interest, the ",(0,t.jsx)(s.code,{children:"HAVING"})," clause can be used, much like a ",(0,t.jsx)(s.code,{children:"WHERE"})," clause, to eliminate groups from the result. The syntax is:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT select_list FROM ... [WHERE ...] GROUP BY ... HAVING boolean_expression\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Expressions in the ",(0,t.jsx)(s.code,{children:"HAVING"})," clause can refer both to grouped expressions and to ungrouped expressions (which necessarily involve an aggregate function)."]}),"\n",(0,t.jsx)(s.p,{children:"Example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;\n x | sum\n---+-----\n a |   4\n b |   5\n(2 rows)\n\n=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';\n x | sum\n---+-----\n a |   4\n b |   5\n(2 rows)\n"})}),"\n",(0,t.jsx)(s.p,{children:"Again, a more realistic example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit\n    FROM products p LEFT JOIN sales s USING (product_id)\n    WHERE s.date > CURRENT_DATE - INTERVAL '4 weeks'\n    GROUP BY product_id, p.name, p.price, p.cost\n    HAVING sum(p.price * s.units) > 5000;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the example above, the ",(0,t.jsx)(s.code,{children:"WHERE"})," clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the ",(0,t.jsx)(s.code,{children:"HAVING"})," clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query."]}),"\n",(0,t.jsxs)(s.p,{children:["If a query contains aggregate function calls, but no ",(0,t.jsx)(s.code,{children:"GROUP BY"})," clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by ",(0,t.jsx)(s.code,{children:"HAVING"}),"). The same is true if it contains a ",(0,t.jsx)(s.code,{children:"HAVING"})," clause, even without any aggregate function calls or ",(0,t.jsx)(s.code,{children:"GROUP BY"})," clause."]})]})}function d(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>i,a:()=>o});var t=n(67294);const a={},r=t.createContext(a);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);